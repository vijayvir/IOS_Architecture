{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf600
{\fonttbl\f0\fnil\fcharset0 LucidaGrande;\f1\fnil\fcharset0 LucidaGrande-Bold;\f2\fmodern\fcharset0 Courier;
}
{\colortbl;\red255\green255\blue255;\red255\green255\blue255;\red0\green0\blue0;\red255\green255\blue255;
\red46\green58\blue89;\red83\green83\blue83;\red39\green78\blue192;\red238\green242\blue247;\red187\green196\blue203;
}
{\*\expandedcolortbl;\csgray\c100000;\cssrgb\c100000\c100000\c100000;\cssrgb\c0\c0\c0;\csgray\c100000;
\cssrgb\c23529\c29804\c42353;\cssrgb\c40000\c40000\c40000;\cssrgb\c20000\c40000\c80000;\cssrgb\c94510\c96078\c97647;\cssrgb\c78039\c81176\c83529;
}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid101\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid2}
{\list\listtemplateid3\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid201\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid3}
{\list\listtemplateid4\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid301\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid4}
{\list\listtemplateid5\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid401\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid5}
{\list\listtemplateid6\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid501\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{none\}}{\leveltext\leveltemplateid502\'00;}{\levelnumbers;}\fi-360\li1440\lin1440 }{\listname ;}\listid6}
{\list\listtemplateid7\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid601\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid7}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}{\listoverride\listid4\listoverridecount0\ls4}{\listoverride\listid5\listoverridecount0\ls5}{\listoverride\listid6\listoverridecount0\ls6}{\listoverride\listid7\listoverridecount0\ls7}}
\margl1440\margr1440\vieww23060\viewh15960\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs56 \cf0 \cb2 \expnd0\expndtw0\kerning0
Cocoa Design Patterns\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 Many of the architectures and mechanisms of the Cocoa environment make effective use of design patterns: abstract designs that solve recurring problems in a particular context. This chapter describes the major implementations of design patterns in Cocoa, focusing in particular on Model-View-Controller and object modeling. This chapter\'92s main purpose is to give you a greater awareness of design patterns in Cocoa and encourage you to take advantage of these patterns in your own software projects.\cb4 \
\pard\pardeftab720\partightenfactor0

\fs48\fsmilli24310 \cf5 \cb2 What Is a Design Pattern?\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 A design pattern is a template for a design that solves a general, recurring problem in a particular context. It is a tool of abstraction that is useful in fields like architecture and engineering as well as software development. The following sections summarize what design patterns are, explains why they\'92re important for object-oriented design, and looks at a sample design pattern.\cb4 \
\pard\pardeftab720\partightenfactor0

\fs37\fsmilli18850 \cf0 \cb2 A Solution to a Problem in a Context\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 As a developer, you might already be familiar with the notion of design patterns in object-oriented programming. They were first authoritatively described and cataloged in Design Patterns: Elements of Reusable Object-Oriented Software, by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (commonly referred to as the \'93Gang of Four\'94). That book, originally published in 1994, was soon followed by other books and articles that further explored and elaborated design patterns in object-oriented systems.\cb4 \
\cb2 The succinct definition of a design pattern is \'93a solution to a problem in a context.\'94 Let\'92s parse this by working backward through the phrase. The context is a recurring situation in which the pattern applies. The problem is the goal you are trying to achieve in this context as well as any constraints that come with the context. And the solution is what you\'92re after: a general design for the context that achieves the goal and resolves the constraints.\cb4 \
\cb2 A design pattern abstracts the key aspects of the structure of a concrete design that has proven to be effective over time. The pattern has a name and identifies the classes and objects that participate in the pattern along with their responsibilities and collaborations. It also spells out consequences (costs and benefits) and the situations in which the pattern can be applied. A design pattern is a kind of template or guide for a particular design; in a sense, a concrete design is an \'93instantiation\'94 of a pattern. Design patterns are not absolute. There is some flexibility in how you can apply them, and often things such as programming language and existing architectures can determine how the pattern is applied.\cb4 \
\cb2 Several themes or principles of design influence design patterns. These design principles are rules of thumb for constructing object-oriented systems, such as \'93encapsulate the aspects of system structure that vary\'94 and \'93program to an interface, not an implementation.\'94 They express important insights. For example, if you isolate the parts of a system that vary, and encapsulate them, they can vary independently of other parts of the system, especially if you define interfaces for them that are not tied to implementation specifics. You can later alter or extend those variable parts without affecting the other parts of the system. You thus eliminate dependencies and reduce couplings between parts, and consequently the system becomes more flexible and easier to change.\cb4 \
\cb2 Benefits such as these make design patterns an important consideration when you\'92re writing software. If you find, adapt, and use patterns in your program\'92s design, that program\'97and the objects and classes that it comprises\'97will be more reusable, more extensible, and easier to change when future requirements demand it. Moreover, programs that are based on design patterns are generally more elegant and efficient than programs that aren\'92t, as they require fewer lines of code to accomplish the same goal.\cb4 \
\pard\pardeftab720\partightenfactor0

\fs37\fsmilli18850 \cf0 \cb2 An Example: The Command Pattern\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 Most of the book by the Gang of Four consists of a catalog of design patterns. It categorizes the patterns in the catalog by scope (class or object) and by purpose (creational, structural, or behavioral). Each entry in the catalog discusses the intent, motivation, applicability, structure, participants, collaborations, consequences, and implementation of a design pattern. One of these entries is the Command pattern (an object-behavioral pattern).\cb4 \
\cb2 The book states the intent of the Command pattern as \'93to encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.\'94 The pattern separates an object sending a message from the objects that receive and evaluate those messages. The originator of the message (the client) encapsulates a request by binding together one or more actions on a specific receiver. The encapsulated message can be passed around between objects, placed in queues or otherwise stored for later invocation, and dynamically modified to vary the receiver or message parameters. Figure 4-1 shows the structure diagram for the pattern.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Figure 4-1
\f0\b0 \'a0\'a0Structure diagram for the Command pattern\cb4 \
\pard\pardeftab720\partightenfactor0
\cf0 {{\NeXTGraphic command_pattern.gif \width11440 \height4300 \noorient
}¬}\pard\pardeftab720\partightenfactor0
\cf0 \
\cb2 For a developer familiar with Cocoa, this short overview of the Command pattern might ring a bell. The pattern perfectly describes a class in the Foundation framework whose purpose is to encapsulate messages: 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSInvocation/a
\f0\fs26 \cf0 . As the pattern\'92s intent states, one of its purposes is to make operations undoable. Invocation objects are used in the Cocoa designs for undo management as well as distributed objects, which is an architecture for interprocess communication. The Command pattern also describes (although less perfectly) the target-action mechanism of Cocoa in which user-interface control objects encapsulate the target and action of the messages they send when users activate them.\cb4 \
\cb2 In its framework classes and in its languages and runtime, Cocoa has already implemented many of the cataloged design patterns for you. (These implementations are described in \cf7 How Cocoa Adapts Design Patterns\cf0 .) You can satisfy many of your development requirements by using one of these \'93off-the-shelf\'94 adaptations of a design pattern. Or you may decide your problem and its context demands a brand new pattern-based design of your own. The important thing is to be aware of patterns when you are developing software and to use them in your designs when appropriate.\cb4 \
\pard\pardeftab720\partightenfactor0

\fs48\fsmilli24310 \cf5 \cb2 How Cocoa Adapts Design Patterns\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 You can find adaptations of design patterns throughout Cocoa, in both its OS X and iOS versions. Mechanisms and architectures based on patterns are common in Cocoa frameworks and in the Objective-C runtime and language. Cocoa often puts its own distinctive spin on a pattern because its designs are influenced by factors such as language capabilities or existing architectures.\cb4 \
\cb2 This section contains summaries of most of the design patterns cataloged in Design Patterns: Elements of Reusable Object-Oriented Software. Each section not only summarizes the pattern but discusses the Cocoa implementations of it. Only patterns that Cocoa implements are listed, and each description of a pattern in the following sections pertains to a particular Cocoa context.\cb4 \
\cb2 Implementations of design patterns in Cocoa come in various forms. Some of the designs described in the following sections\'97such as protocols and categories\'97are features of the Objective-C language. In other cases, the \'93instance of a pattern\'94 is implemented in one class or a group of related classes (for example, class clusters and singleton classes). And in other cases the pattern adaptation is a major framework architecture, such as the responder chain. Some of the pattern-based mechanisms you get almost \'93for free\'94 while others require some work on your part. And even if Cocoa does not implement a pattern, you are encouraged to do so yourself when the situation warrants it; for example, object composition (Decorator pattern) is often a better technique than subclassing for extending class behavior.\cb4 \
\cb2 Two design patterns are reserved for later sections, Model-View-Controller (MVC) and object modeling. MVC is a compound, or aggregate pattern, meaning that it is based on several catalog patterns. Object modeling has no counterpart in the Gang of Four catalog, instead originating from the domain of relational databases. Yet MVC and object modeling are perhaps the most important and pervasive design patterns in Cocoa, and to a large extent they are interrelated patterns. They play a crucial role in the design of several technologies, including bindings, undo management, scripting, and the document architecture. To learn more about these patterns, see \cf7 The Model-View-Controller Design Pattern\cf0  and \cf7 Object Modeling\cf0 .\cb4 \
\pard\pardeftab720\partightenfactor0

\fs37\fsmilli18850 \cf0 \cb2 Abstract Factory\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 The Abstract Factory pattern provides an interface for creating families of related or dependent objects without specifying their concrete classes. The client is decoupled from any of the specifics of the concrete object obtained from the factory.\cb4 \
\pard\pardeftab720\partightenfactor0

\fs32\fsmilli16250 \cf0 \cb2 Class Cluster\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 A class cluster is an architecture that groups a number of private concrete subclasses under a public abstract superclass. The abstract superclass declares methods for creating instances of its private subclasses. The superclass dispenses an object of the proper concrete subclass based on the creation method invoked. Each object returned may belong to a different private concrete subclass.\cb4 \
\cb2 Class clusters in Cocoa can generate only objects whose storage of data can vary depending on circumstances. The Foundation framework has class clusters for {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSStringClassCluster/Description.html#//apple_ref/occ/cl/NSString"}}{\fldrslt 
\f2\fs26\fsmilli13390 \cf7 NSString}}, {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSDataClassCluster/Description.html#//apple_ref/occ/cl/NSData"}}{\fldrslt 
\f2\fs26\fsmilli13390 \cf7 NSData}}, {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSDictionaryClassClstr/Description.html#//apple_ref/occ/cl/NSDictionary"}}{\fldrslt 
\f2\fs26\fsmilli13390 \cf7 NSDictionary}}, {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSSetClassCluster/Description.html#//apple_ref/occ/cl/NSSet"}}{\fldrslt 
\f2\fs26\fsmilli13390 \cf7 NSSet}}, and {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSArrayClassCluster/Description.html#//apple_ref/occ/cl/NSArray"}}{\fldrslt 
\f2\fs26\fsmilli13390 \cf7 NSArray}} objects. The public superclasses include these immutable classes as well as the complementary mutable classes {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSStringClassCluster/Description.html#//apple_ref/occ/cl/NSMutableString"}}{\fldrslt 
\f2\fs26\fsmilli13390 \cf7 NSMutableString}}, {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSDataClassCluster/Description.html#//apple_ref/occ/cl/NSMutableData"}}{\fldrslt 
\f2\fs26\fsmilli13390 \cf7 NSMutableData}}, {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSDictionaryClassClstr/Description.html#//apple_ref/occ/cl/NSMutableDictionary"}}{\fldrslt 
\f2\fs26\fsmilli13390 \cf7 NSMutableDictionary}}, {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSSetClassCluster/Description.html#//apple_ref/occ/cl/NSMutableSet"}}{\fldrslt 
\f2\fs26\fsmilli13390 \cf7 NSMutableSet}}, and {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSArrayClassCluster/Description.html#//apple_ref/occ/cl/NSMutableArray"}}{\fldrslt 
\f2\fs26\fsmilli13390 \cf7 NSMutableArray}}.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Uses and Limitations\cb4 \
\pard\pardeftab720\partightenfactor0

\f0\b0 \cf0 \cb2 You use one of the public classes of a class cluster when you want to create immutable or mutable objects of the type represented by the cluster. With class clusters there is a trade-off between simplicity and extensibility. A class cluster simplifies the interface to a class and thus makes it easier to learn and use the class. However, it is generally more difficult to create custom subclasses of the abstract superclass of a class cluster.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Further Reading:
\f0\b0 \'a0{\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/Cocoa/Conceptual/CocoaFundamentals/CocoaObjects/CocoaObjects.html#//apple_ref/doc/uid/TP40002974-CH4-SW34"}}{\fldrslt \cf7 Class Clusters}} provides more information about class clusters in Cocoa.\cb4 \
\
\pard\pardeftab720\partightenfactor0

\fs37\fsmilli18850 \cf0 \cb2 Adapter\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 The Adapter design pattern converts the interface of a class into another interface that clients expect. Adapter lets classes work together that couldn\'92t otherwise because of incompatible interfaces. It decouples the client from the class of the targeted object.\cb4 \
\pard\pardeftab720\partightenfactor0

\fs32\fsmilli16250 \cf0 \cb2 Protocols\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 A protocol is a language-level (Objective-C) feature that makes it possible to define interfaces that are instances of the Adapter pattern. A protocol is essentially a series of method declarations unassociated with a class. (In Java, interface is synonymous with protocol.) If you want a client object to communicate with another object, but the objects\'92 incompatible interfaces make that difficult, you can define a protocol. The class of the other object then formally adopts the protocol and \'93conforms\'94 to it by implementing one or more of the methods of the protocol. The protocol may require the conforming class to implement some of its methods and may leave the implementation of others optional. The client object can then send messages to the other object through the protocol interface.\cb4 \
\cb2 Protocols make a set of method declarations independent of the class hierarchy. They make it possible to group objects on the basis of conformance to a protocol as well as class inheritance. The 
\f2\fs26\fsmilli13390 \cf6 NSObject
\f0\fs26 \cf0  method {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Protocols/NSObject/Description.html#//apple_ref/occ/intfm/NSObject/conformsToProtocol:"}}{\fldrslt 
\f2\fs26\fsmilli13390 \cf7 conformsToProtocol:}} permits you to verify an object\'92s protocol affiliation.\cb4 \
\cb2 Cocoa has informal protocols as well as formal protocols. An informal protocol is a category on the {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSObject/Description.html#//apple_ref/occ/cl/NSObject"}}{\fldrslt 
\f2\fs26\fsmilli13390 \cf7 NSObject}} class, thus making any object a potential implementer of any method in the category (see \cf7 Categories\cf0 ). The methods in an informal protocol can be selectively implemented. Informal protocols are part of the implementation of the delegation mechanism in OS X (see \cf7 Delegation\cf0 ).\cb4 \
\cb2 Note that the design of protocols does not perfectly match the description of the Adapter pattern. But it achieves the goal of the pattern: allowing classes with otherwise incompatible interfaces to work together.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Uses and Limitations\cb4 \
\pard\pardeftab720\partightenfactor0

\f0\b0 \cf0 \cb2 You use a protocol primarily to declare an interface that hierarchically unrelated classes are expected to conform to if they want to communicate. But you can also use protocols to declare an interface of an object while concealing its class. The Cocoa frameworks include many formal protocols that enable custom subclasses to communicate with them for specific purposes. For example, the Foundation framework includes the {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Protocols/NSObject/Description.html#//apple_ref/occ/intf/NSObject"}}{\fldrslt 
\f2\fs26\fsmilli13390 \cf7 NSObject}}, {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Protocols/NSCopying/Description.html#//apple_ref/occ/intf/NSCopying"}}{\fldrslt 
\f2\fs26\fsmilli13390 \cf7 NSCopying}}, and {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Protocols/NSCoding/Description.html#//apple_ref/occ/intf/NSCoding"}}{\fldrslt 
\f2\fs26\fsmilli13390 \cf7 NSCoding}} protocols, which are all very important ones. AppKit protocols include 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSDraggingInfo/a
\f0\fs26 \cf0 , 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSTextInput/a
\f0\fs26 \cf0 , and 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSChangeSpelling/a
\f0\fs26 \cf0 . UIKit protocols include 
\f2\fs26\fsmilli13390 \cf6 a target="_self" UITextInputTraits/a
\f0\fs26 \cf0 , 
\f2\fs26\fsmilli13390 \cf6 a target="_self" UIWebViewDelegate/a
\f0\fs26 \cf0 , and 
\f2\fs26\fsmilli13390 \cf6 a target="_self" UITableViewDataSource/a
\f0\fs26 \cf0 .\cb4 \
\cb2 Formal protocols implicitly require the conforming class to implement all declared methods. However, they can mark single methods or groups of methods with the 
\f2\fs26\fsmilli13390 \cf6 @optional
\f0\fs26 \cf0  directive, and the conforming class may choose to implement those. They are also fragile; once you define a protocol and make it available to other classes, future changes to it (except for additional optional methods) can break those classes.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Further Reading:
\f0\b0 \'a0More more information on formal protocols, see {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/Cocoa/Conceptual/ObjectiveC/Chapters/ocProtocols.html#//apple_ref/doc/uid/TP30001163-CH15"}}{\fldrslt \cf7 Protocols}} in {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/Cocoa/Conceptual/ObjectiveC/Introduction/introObjectiveC.html#//apple_ref/doc/uid/TP30001163"}}{\fldrslt \cf7 The Objective-C Programming Language}}.\cb4 \
\
\pard\pardeftab720\partightenfactor0

\fs37\fsmilli18850 \cf0 \cb2 Chain of Responsibility\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 The Chain of Responsibility design pattern decouples the sender of a request from its receiver by giving more than one object a chance to handle the request. The pattern chains the receiving objects together and passes the request along the chain until an object handles it. Each object in the chain either handles the request or passes it to the next object in the chain.\cb4 \
\pard\pardeftab720\partightenfactor0

\fs32\fsmilli16250 \cf0 \cb2 Responder Chain\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 The application frameworks include an architecture known as the responder chain. This chain consists of a series of responder objects (that is, objects inheriting from 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSResponder/a
\f0\fs26 \cf0  or, in UIKit, 
\f2\fs26\fsmilli13390 \cf6 a target="_self" UIResponder/a
\f0\fs26 \cf0 ) along which an event (for example, a mouse click) or action message is passed and (usually) eventually handled. If a given responder object doesn\'92t handle a particular message, it passes the message to the next responder in the chain. The order of responder objects in the chain is generally determined by the view hierarchy, with the progression from lower-level to higher-level responders in the hierarchy, culminating in the window object that manages the view hierarchy, the delegate of the window object, or the global application object. The paths of events and action messages up the responder chain is different. An application can have as many responder chains as it has windows (or even local hierarchies of views); but only one responder chain can be active at a time\'97the one associated with the currently active window.\cb4 \
\cb2 The AppKit framework also implements a similar chain of responders for error handling.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 iOS Note:
\f0\b0 \'a0UIKit implements the responder chain differently than AppKit does. If a view is managed by a 
\f2\fs26\fsmilli13390 \cf6 a target="_self" UIViewController/a
\f0\fs26 \cf0  object, the view controller becomes the next responder in the chain (and from there the event or action message passes to the view\'92s superview). In addition, UIKit does not support a document architecture per se; therefore there are no document objects or window-controller objects in the responder chain. There is also no error-handling responder chain in iOS.\cb4 \
\
\pard\pardeftab720\partightenfactor0
\cf0 \cb2 The design of the view hierarchy, which is closely related to the responder chain, adapts the Composite pattern (\cf7 Composite\cf0 ). Action messages\'97messages originating from control objects\'97are based on the target-action mechanism, which is an instance of the Command pattern (\cf7 Command\cf0 ).\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Uses and Limitations\cb4 \
\pard\pardeftab720\partightenfactor0

\f0\b0 \cf0 \cb2 When you construct a user interface for a program either by using Interface Builder or programmatically, you get one or more responder chains \'93for free.\'94 The responder chain goes hand in hand with a view hierarchy, which you get automatically when you make a view object a subview of a window\'92s content view. If you have a custom view added to a view hierarchy, it becomes part of the responder chain. If you implement the appropriate 
\f2\fs26\fsmilli13390 \cf6 NSResponder
\f0\fs26 \cf0  or 
\f2\fs26\fsmilli13390 \cf6 UIResponder
\f0\fs26 \cf0  methods, you can receive and handle events and action messages. A custom object that is a delegate of a window object or the global application object (
\f2\fs26\fsmilli13390 \cf6 NSApp
\f0\fs26 \cf0  in AppKit) can also receive and handle those messages.\cb4 \
\cb2 You can also programmatically inject custom responders into the responder chain and you can programmatically manipulate the order of responders.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Further Reading:
\f0\b0 \'a0The AppKit responder chains for handling events and action messages and for handling errors are described in a target="_self" Cocoa Event Handling Guide/a and a target="_self" Error Handling Programming Guide/a. The UIKit responder chain is described in a target="_self" Event Handling Guide for iOS/a. The view hierarchy is a related design pattern that is summarized in \cf7 Composite\cf0 .\cb4 \
\
\pard\pardeftab720\partightenfactor0

\fs37\fsmilli18850 \cf0 \cb2 Command\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 The Command design pattern encapsulates a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations. The request object binds together one or more actions on a specific receiver. The Command pattern separates an object making a request from the objects that receive and execute that request.\cb4 \
\pard\pardeftab720\partightenfactor0

\fs32\fsmilli16250 \cf0 \cb2 Invocation Objects\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 An instance of the 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSInvocation/a
\f0\fs26 \cf0  class encapsulates an Objective-C message. An invocation object contains a target object, method selector, and method parameters. You can dynamically change the target of the message dispatched by the invocation object as well as its parameters; once the invocation is executed, you can also obtain the return value from the object. With a single invocation object, you can repeatedly invoke a message with multiple variations in target and parameters.\cb4 \
\cb2 The creation of an 
\f2\fs26\fsmilli13390 \cf6 NSInvocation
\f0\fs26 \cf0  object requires an {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSMethodSignature/Description.html#//apple_ref/occ/cl/NSMethodSignature"}}{\fldrslt 
\f2\fs26\fsmilli13390 \cf7 NSMethodSignature}} object, which is an object that encapsulates type information related to the parameters and return value of a method. An 
\f2\fs26\fsmilli13390 \cf6 NSMethodSignature
\f0\fs26 \cf0  object, in turn, is created from a method selector. The implementation of 
\f2\fs26\fsmilli13390 \cf6 NSInvocation
\f0\fs26 \cf0  also makes use of functions of the Objective-C runtime.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Uses and Limitations\cb4 \
\pard\pardeftab720\partightenfactor0

\f2\b0\fs26\fsmilli13390 \cf6 \cb2 NSInvocation
\f0\fs26 \cf0  objects are part of the programmatic interfaces of distributed objects, undo management, message forwarding, and timers. You can also use invocation objects in similar contexts where you need to decouple an object sending a message from the object that receives the message.\cb4 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb2 The distributed objects technology is for interprocess communication. See \cf7 Proxy\cf0  for more on distributed objects.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Further Reading:
\f0\b0 \'a0See a target="_self" NSInvocation Class Reference/a for details on invocation objects. Also, consult the following documents for information about related technologies: a target="_self" Undo Architecture/a, a target="_self" Timer Programming Topics/a, and the {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/Cocoa/Conceptual/OOPandObjC1/Articles/ocRuntimeSystem.html#//apple_ref/doc/uid/TP40005191-CH9"}}{\fldrslt \cf7 The Runtime System}} in {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/Cocoa/Conceptual/ObjectiveC/Introduction/introObjectiveC.html#//apple_ref/doc/uid/TP30001163"}}{\fldrslt \cf7 The Objective-C Programming Language}}.\cb4 \
\
\pard\pardeftab720\partightenfactor0

\fs32\fsmilli16250 \cf0 \cb2 The Target-Action Mechanism\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 The target-action mechanism enables a control object\'97that is, an object such as a button, slider, or text field\'97to send a message to another object that can interpret the message and handle it as an application-specific instruction. The receiving object, or the target, is usually a custom controller object. The message\'97named an action message\'97is determined by a selector, a unique runtime identifier of a method.\cb4 \
\cb2 In the AppKit framework, the cell object that a control owns typically encapsulates the target and action. When the user clicks or otherwise activates the control, the control extracts the information from its cell and sends the message. (A menu item also encapsulates target and action, and sends an action message when the user chooses it.) The target-action mechanism can work on the basis of a selector (and not a method signature) because the signature of an action method in AppKit by convention is always the same.\cb4 \
\cb2 In UIKit, the target-action mechanism does not rely on cells. Instead, a control maps a target and action to one or more multitouch events that can occur on the control.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Uses and Limitations\cb4 \
\pard\pardeftab720\partightenfactor0

\f0\b0 \cf0 \cb2 When creating a Cocoa application, you can set a control\'92s action and target through the Interface Builder application. You thereby let the control initiate custom behavior without writing any code for the control itself. The action selector and target connection are archived in a nib file and are restored when the nib is unarchived. You can also change the target and action dynamically by sending the control or its cell 
\f2\fs26\fsmilli13390 \cf6 setTarget:
\f0\fs26 \cf0  and 
\f2\fs26\fsmilli13390 \cf6 setAction:
\f0\fs26 \cf0  messages.\cb4 \
\cb2 A Cocoa application for OS X can use the target-action mechanism to instruct a custom controller object to transfer data from the user interface to a model object, or to display data in a model object. The Cocoa bindings technology obviates the need to use target-action for this purpose. See a target="_self" Cocoa Bindings Programming Topics/a for more about this technology.\cb4 \
\cb2 Controls and cells do not retain their targets. See {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/Cocoa/Conceptual/CocoaFundamentals/CommunicatingWithObjects/CommunicateWithObjects.html#//apple_ref/doc/uid/TP40002974-CH7-SW16"}}{\fldrslt \cf7 Ownership of Delegates, Observers, and Targets}} for further information.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Further Reading:
\f0\b0 \'a0See {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/Cocoa/Conceptual/CocoaFundamentals/CommunicatingWithObjects/CommunicateWithObjects.html#//apple_ref/doc/uid/TP40002974-CH7-SW14"}}{\fldrslt \cf7 The Target-Action Mechanism}} for further information.\cb4 \
\
\pard\pardeftab720\partightenfactor0

\fs37\fsmilli18850 \cf0 \cb2 Composite\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 The Composite design pattern composes related objects into tree structures to represent part-whole hierarchies. The pattern lets clients treat individual objects and compositions of objects uniformly.\cb4 \
\cb2 The Composite pattern is part of the Model-View-Controller aggregate pattern, which is describe in \cf7 The Model-View-Controller Design Pattern\cf0 .\cb4 \
\pard\pardeftab720\partightenfactor0

\fs32\fsmilli16250 \cf0 \cb2 View Hierarchy\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 The views (
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSView/a
\f0\fs26 \cf0  or 
\f2\fs26\fsmilli13390 \cf6 a target="_self" UIView/a
\f0\fs26 \cf0  objects) in a window are internally structured into a view hierarchy. At the root of the hierarchy is a window (
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSWindow/a
\f0\fs26 \cf0  or 
\f2\fs26\fsmilli13390 \cf6 a target="_self" UIWindow/a
\f0\fs26 \cf0  object) and its content view, a transparent view that fills the window\'92s content rectangle. Views that are added to the content view become subviews of it, and they become the superviews of any views added to them. Except for the content view, a view has one (and only one) superview and zero or any number of subviews. You perceive this structure as containment: a superview contains its subviews. Figure 4-2 shows the visual and structural aspects of the view hierarchy.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Figure 4-2
\f0\b0 \'a0\'a0The view hierarchy, visual and structural\cb4 \
\pard\pardeftab720\partightenfactor0
\cf0 {{\NeXTGraphic view_hierarchy.gif \width7200 \height8520 \noorient
}¬}\pard\pardeftab720\partightenfactor0
\cf0 \
\cb2 The view hierarchy is a structural architecture that plays a part in both drawing and event handling. A view has two bounding rectangles, its frame and its bounds, that affect how graphics operations with the view take place. The frame is the exterior boundary; it locates the view in its superview\'92s coordinate system, defines its size, and clips drawing to the view\'92s edges. The bounds, the interior bounding rectangle, defines the internal coordinate system of the surface where the view draws itself.\cb4 \
\cb2 When a window is asked by the windowing system to prepare itself for display, superviews are asked to render themselves before their subviews. When you send some messages to a view\'97for example, a message that requests a view to redraw itself\'97the message is propagated to subviews. You can thus treat a branch of the view hierarchy as a unified view.\cb4 \
\cb2 The view hierarchy is also used by the responder chain for handling events and action messages. See the summary of the responder chain in \cf7 Chain of Responsibility\cf0 .\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Uses and Limitations\cb4 \
\pard\pardeftab720\partightenfactor0

\f0\b0 \cf0 \cb2 You create or modify a view hierarchy whenever you add a view to another view, either programmatically or using Interface Builder. The AppKit framework automatically handles all the relationships associated with the view hierarchy.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Further Reading:
\f0\b0 \'a0a target="_self" Cocoa Drawing Guide/a discusses the view hierarchy in Mac apps.\cb4 \
\
\pard\pardeftab720\partightenfactor0

\fs37\fsmilli18850 \cf0 \cb2 Decorator\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 The Decorator design pattern attaches additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality. As does subclassing, adaptation of the Decorator pattern allows you to incorporate new behavior without modifying existing code. Decorators wrap an object of the class whose behavior they extend. They implement the same interface as the object they wrap and add their own behavior either before or after delegating a task to the wrapped object. The Decorator pattern expresses the design principle that classes should be open to extension but closed to modification.\cb4 \
\pard\pardeftab720\partightenfactor0

\fs32\fsmilli16250 \cf0 \cb2 General Comments\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 Decorator is a pattern for object composition, which is something that you are encouraged to do in your own code (see {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/Cocoa/Conceptual/CocoaFundamentals/AddingBehaviortoaCocoaProgram/AddingBehaviorCocoa.html#//apple_ref/doc/uid/TP40002974-CH5-SW22"}}{\fldrslt \cf7 When to Make a Subclass}}). Cocoa, however, provides some classes and mechanisms of its own (discussed in the following sections) that are based on the pattern. In these implementations, the extending object does not completely duplicate the interface of the object that it wraps, and the implementations use different techniques for interface sharing.\cb4 \
\cb2 Cocoa uses the Decorator pattern in the implementation of several of its classes, including {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSAttributedStrngClstr/Description.html#//apple_ref/occ/cl/NSAttributedString"}}{\fldrslt 
\f2\fs26\fsmilli13390 \cf7 NSAttributedString}}, 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSScrollView/a
\f0\fs26 \cf0 , and 
\f2\fs26\fsmilli13390 \cf6 a target="_self" UIDatePicker/a
\f0\fs26 \cf0 . The latter two classes are examples of compound views, which group together simple objects of other view classes and coordinate their interaction.\cb4 \
\pard\pardeftab720\partightenfactor0

\fs32\fsmilli16250 \cf0 \cb2 Delegation\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 Delegation is a mechanism by which a host object embeds a weak reference (weak in the sense that it\'92s a simple pointer reference, unretained) to another object\'97its delegate\'97and periodically sends messages to the delegate when it requires its input for a task. The host object is generally an \'93off-the-shelf\'94 framework object (such as an 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSWindow/a
\f0\fs26 \cf0  or 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSXMLParser/a
\f0\fs26 \cf0  object) that is seeking to accomplish something, but can only do so in a generic fashion. The delegate, which is almost always an instance of a custom class, acts in coordination with the host object, supplying program-specific behavior at certain points in the task (see Figure 4-3). Thus delegation makes it possible to modify or extend the behavior of another object without the need for subclassing.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Figure 4-3
\f0\b0 \'a0\'a0Framework object sending a message to its delegate\cb4 \
\pard\pardeftab720\partightenfactor0
\cf0 {{\NeXTGraphic delegation.gif \width7800 \height3180 \noorient
}¬}\pard\pardeftab720\partightenfactor0
\cf0 \
\cb2 Delegation, in the simple sense of one object delegating a task to another object, is a common technique in object-oriented programming. However, Cocoa implements delegation in a unique way. A host class uses a formal protocol or an informal protocol to define an interface that the delegate object may choose to implement. All the methods in the informal protocol are optional, and the formal protocol may declare optional methods, allowing the delegate to implement only some of the methods in the protocol. Before it attempts to send a message to its delegate, the host object determines whether it implements the method (via a {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Protocols/NSObject/Description.html#//apple_ref/occ/intfm/NSObject/respondsToSelector:"}}{\fldrslt 
\f2\fs26\fsmilli13390 \cf7 respondsToSelector:}} message) to avoid runtime exceptions. For more on formal and informal protocols, see \cf7 Protocols\cf0 .\cb4 \
\cb2 Some classes in the Cocoa frameworks also send messages to their data sources. A data source is identical in all respects to a delegate, except that the intent is to provide the host object with data to populate a browser, a table view, or similar user-interface view. A data source, unlike a delegate, may also be required to implement some methods of the protocol.\cb4 \
\cb2 Delegation is not a strict implementation of the Decorator pattern. The host (delegating) object does not wrap an instance of the class it wants to extend; indeed, it\'92s the other way around, in that the delegate is specializing the behavior of the delegating framework class. There is no sharing of interface either, other than the delegation methods declared by the framework class.\cb4 \
\cb2 Delegation in Cocoa is also part of the Template Method pattern (\cf7 Template Method\cf0 ).\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Uses and Limitations\cb4 \
\pard\pardeftab720\partightenfactor0

\f0\b0 \cf0 \cb2 Delegation is a common design in the Cocoa frameworks. Many classes in the AppKit and UIKit frameworks send messages to delegates, including 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSApplication/a
\f0\fs26 \cf0 , 
\f2\fs26\fsmilli13390 \cf6 a target="_self" UIApplication/a
\f0\fs26 \cf0 , 
\f2\fs26\fsmilli13390 \cf6 a target="_self" UITableView/a
\f0\fs26 \cf0 , and several subclasses of 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSView/a
\f0\fs26 \cf0 . Some classes in the Foundation framework, such as 
\f2\fs26\fsmilli13390 \cf6 NSXMLParser
\f0\fs26 \cf0  and 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSStream/a
\f0\fs26 \cf0 , also maintain delegates. You should always use a class\'92s delegation mechanism instead of subclassing the class, unless the delegation methods do not allow you to accomplish your goal.\cb4 \
\cb2 Although you can dynamically change the delegate, only one object can be a delegate at a time. Thus if you want multiple objects to be informed of a particular program event at the same time, you cannot use delegation. However, you can use the notification mechanism for this purpose. A delegate automatically receives notifications from its delegating framework object as long as the delegate implements one or more of the notification methods declared by the framework class. See the discussion of notifications in the Observer pattern (\cf7 Observer\cf0 ).\cb4 \
\cb2 Delegating objects in AppKit do not retain their delegates or data sources. See {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/Cocoa/Conceptual/CocoaFundamentals/CommunicatingWithObjects/CommunicateWithObjects.html#//apple_ref/doc/uid/TP40002974-CH7-SW16"}}{\fldrslt \cf7 Ownership of Delegates, Observers, and Targets}} for further information.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Further Reading:
\f0\b0 \'a0For further information on delegation, see {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/Cocoa/Conceptual/CocoaFundamentals/CommunicatingWithObjects/CommunicateWithObjects.html#//apple_ref/doc/uid/TP40002974-CH7-SW18"}}{\fldrslt \cf7 Delegates and Data Sources}}\'93.\cb4 \
\
\pard\pardeftab720\partightenfactor0

\fs32\fsmilli16250 \cf0 \cb2 Categories\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 A category is a feature of the Objective-C language that enables you to add methods (interface and implementation) to a class without having to make a subclass. There is no runtime difference\'97within the scope of your program\'97between the original methods of the class and the methods added by the category. The methods in the category become part of the class type and are inherited by all the class\'92s subclasses.\cb4 \
\cb2 As with delegation, categories are not a strict adaptation of the Decorator pattern, fulfilling the intent but taking a different path to implementing that intent. The behavior added by categories is a compile-time artifact, and is not something dynamically acquired. Moreover, categories do not encapsulate an instance of the class being extended.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Uses and Limitations\cb4 \
\pard\pardeftab720\partightenfactor0

\f0\b0 \cf0 \cb2 The Cocoa frameworks define numerous categories, most of them informal protocols (which are summarized in \cf7 Protocols\cf0 ). Often they use categories to group related methods. You may implement categories in your code to extend classes without subclassing or to group related methods. However, you should be aware of these caveats:\cb4 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls1\ilvl0\cf0 \cb2 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
You cannot add instance variables to the class.\cb4 \
\ls1\ilvl0\cb2 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
If you override existing methods of the class, your application may behave unpredictably.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Further Reading:
\f0\b0 \'a0See {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/Cocoa/Conceptual/ObjectiveC/Chapters/ocDefiningClasses.html#//apple_ref/doc/uid/TP30001163-CH12"}}{\fldrslt \cf7 Defining a Class}} in {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/Cocoa/Conceptual/ObjectiveC/Introduction/introObjectiveC.html#//apple_ref/doc/uid/TP30001163"}}{\fldrslt \cf7 The Objective-C Programming Language}} for more information on categories.\cb4 \
\
\pard\pardeftab720\partightenfactor0

\fs37\fsmilli18850 \cf0 \cb2 Facade\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 The Facade design pattern provides a unified interface to a set of interfaces in a subsystem. The pattern defines a higher-level interface that makes the subsystem easier to use by reducing complexity and hiding the communication and dependencies between subsystems.\cb4 \
\pard\pardeftab720\partightenfactor0

\fs32\fsmilli16250 \cf0 \cb2 NSImage\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 The 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSImage/a
\f0\fs26 \cf0  class of the AppKit framework provides a unified interface for loading and using images that can be bitmap-based (such as those in JPEG, PNG, or TIFF format) or vector-based (such as those in EPS or PDF format). 
\f2\fs26\fsmilli13390 \cf6 NSImage
\f0\fs26 \cf0  can keep more than one representation of the same image; each representation is a kind of 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSImageRep/a
\f0\fs26 \cf0  object. 
\f2\fs26\fsmilli13390 \cf6 NSImage
\f0\fs26 \cf0  automates the choice of the representation that is appropriate for a particular type of data and for a given display device. It also hides the details of image manipulation and selection so that the client can use many different underlying representations interchangeably.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Uses and Limitations\cb4 \
\pard\pardeftab720\partightenfactor0

\f0\b0 \cf0 \cb2 Because 
\f2\fs26\fsmilli13390 \cf6 NSImage
\f0\fs26 \cf0  supports several different representations of what an image is, some requested attributes might not apply. For example, asking an image for the color of a pixel does not work if the underlying image representation is vector-based and device-independent.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Note:
\f0\b0 \'a0See a target="_self" Cocoa Drawing Guide/a for a discussion of 
\f2\fs26\fsmilli13390 \cf6 NSImage
\f0\fs26 \cf0  and image representations.\cb4 \
\
\pard\pardeftab720\partightenfactor0

\fs37\fsmilli18850 \cf0 \cb2 Iterator\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 The Iterator design pattern provides a way to access the elements of an aggregate object (that is, a collection) sequentially without exposing its underlying representation. The Iterator pattern transfers the responsibility for accessing and traversing the elements of a collection from the collection itself to an iterator object. The Iterator defines an interface for accessing collection elements and keeps track of the current element. Different iterators can carry out different traversal policies.\cb4 \
\pard\pardeftab720\partightenfactor0

\fs32\fsmilli16250 \cf0 \cb2 Enumerators\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 The {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSEnumerator/Description.html#//apple_ref/occ/cl/NSEnumerator"}}{\fldrslt 
\f2\fs26\fsmilli13390 \cf7 NSEnumerator}} class in the Foundation framework implements the Iterator pattern. The private, concrete subclass of the abstract 
\f2\fs26\fsmilli13390 \cf6 NSEnumerator
\f0\fs26 \cf0  class returns enumerator objects that sequentially traverse collections of various types\'97arrays, sets, dictionaries (values and keys)\'97returning objects in the collection to clients.\cb4 \
\pard\pardeftab720\partightenfactor0
{\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSDirectoryEnumerator/Description.html#//apple_ref/occ/cl/NSDirectoryEnumerator"}}{\fldrslt 
\f2\fs26\fsmilli13390 \cf7 \cb2 NSDirectoryEnumerator}}\cb2  is a distantly related class. Instances of this class recursively enumerate the contents of a directory in the file system.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Uses and Limitations\cb4 \
\pard\pardeftab720\partightenfactor0

\f0\b0 \cf0 \cb2 The collection classes such as {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSArrayClassCluster/Description.html#//apple_ref/occ/cl/NSArray"}}{\fldrslt 
\f2\fs26\fsmilli13390 \cf7 NSArray}}, {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSSetClassCluster/Description.html#//apple_ref/occ/cl/NSSet"}}{\fldrslt 
\f2\fs26\fsmilli13390 \cf7 NSSet}}, and {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSDictionaryClassClstr/Description.html#//apple_ref/occ/cl/NSDictionary"}}{\fldrslt 
\f2\fs26\fsmilli13390 \cf7 NSDictionary}} include methods that return an enumerator appropriate to the type of collection. All enumerators work in the same manner. You send a {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSEnumerator/Description.html#//apple_ref/occ/instm/NSEnumerator/nextObject"}}{\fldrslt 
\f2\fs26\fsmilli13390 \cf7 nextObject}} message to the enumerator object in a loop that exits when 
\f2\fs26\fsmilli13390 \cf6 nil
\f0\fs26 \cf0  is returned instead of the next object in the collection.\cb4 \
\cb2 You can also use fast enumeration to access the elements of a collection; this language feature is described in {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/Cocoa/Conceptual/CocoaFundamentals/CocoaObjects/CocoaObjects.html#//apple_ref/doc/uid/TP40002974-CH4-SW47"}}{\fldrslt \cf7 Fast Enumeration}}.\cb4 \
\pard\pardeftab720\partightenfactor0

\fs37\fsmilli18850 \cf0 \cb2 Mediator\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 The Mediator design pattern defines an object that encapsulates how a set of objects interact. Mediator promotes loose coupling by keeping objects from referring to each other explicitly, and it lets you vary their interaction independently. These objects can thus remain more reusable.\cb4 \
\cb2 A "mediator object\'94 in this pattern centralizes complex communication and control logic between objects in a system. These objects tell the mediator object when their state changes and, in turn, respond to requests from the mediator object.\cb4 \
\pard\pardeftab720\partightenfactor0

\fs32\fsmilli16250 \cf0 \cb2 Controller Classes in the AppKit Framework\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 The Model-View-Controller design pattern assigns roles to the objects in an object-oriented system such as an application. They can be model objects, which contain the data of the application and manipulate that data; they can be view objects, which present the data and respond to user actions; or they can be controller objects, which mediate between the model and view objects. Controller objects fit the Mediator pattern.\cb4 \
\cb2 In Cocoa, controller objects can be of two general types: mediating controllers or coordinating controllers. Mediating controllers mediate the flow of data between view objects and model objects in an application. Mediating controllers are typically 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSController/a
\f0\fs26 \cf0  objects. Coordinating controllers implement the centralized communication and control logic for an application, acting as delegates for framework objects and as targets for action messages. They are typically 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSWindowController/a
\f0\fs26 \cf0  objects or instances of custom {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSObject/Description.html#//apple_ref/occ/cl/NSObject"}}{\fldrslt 
\f2\fs26\fsmilli13390 \cf7 NSObject}} subclasses. Because they are so highly specialized for a particular program, coordinating controllers tend not to be reusable.\cb4 \
\cb2 The abstract class 
\f2\fs26\fsmilli13390 \cf6 NSController
\f0\fs26 \cf0  and its concrete subclasses in the AppKit framework are part of the Cocoa technology of bindings, which automatically synchronizes the data contained in model objects and displayed and edited in view objects. For example, if a user edits a string in a text field, the bindings technology communicates that change\'97through a mediating controller\'97to the appropriate property of the bound model object. All programmers need to do is properly design their model objects and, using Interface Builder, establish bindings between the view, controller, and model objects of a program.\cb4 \
\cb2 Instances of the concrete public controller classes are available from the Interface Builder library and hence are highly reusable. They provide services such as the management of selections and placeholder values. These objects perform the following specific functions:\cb4 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls2\ilvl0
\f2\fs26\fsmilli13390 \cf6 \cb2 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
a target="_self" NSObjectController/a
\f0\fs26 \cf0  manages a single model object.\cb4 \
\ls2\ilvl0
\f2\fs26\fsmilli13390 \cf6 \cb2 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
a target="_self" NSArrayController/a
\f0\fs26 \cf0  manages an array of model objects and maintains a selection; it also allows you to add objects to and remove objects from the array.\cb4 \
\ls2\ilvl0
\f2\fs26\fsmilli13390 \cf6 \cb2 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
a target="_self" NSTreeController/a
\f0\fs26 \cf0  enables you to add, remove, and manage model objects in a hierarchical tree structure.\cb4 \
\ls2\ilvl0
\f2\fs26\fsmilli13390 \cf6 \cb2 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
a target="_self" NSUserDefaultsController/a
\f0\fs26 \cf0  provides a convenient interface to the preferences (user defaults) system.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Uses and Limitations\cb4 \
\pard\pardeftab720\partightenfactor0

\f0\b0 \cf0 \cb2 Generally you use 
\f2\fs26\fsmilli13390 \cf6 NSController
\f0\fs26 \cf0  objects as mediating controllers because these objects are designed to communicate data between the view objects and model objects of an application. To use a mediating controller, you typically drag the object from the Interface Builder library, specify the model-object property keys, and establish the bindings between view and model objects using the Bindings pane of the Interface Builder Info window. You can also subclass 
\f2\fs26\fsmilli13390 \cf6 NSController
\f0\fs26 \cf0  or one of its subclasses to get more specialized behavior.\cb4 \
\cb2 You can potentially make bindings between almost any pair of objects as long as those objects comply with the 
\f2\fs26\fsmilli13390 \cf6 NSKeyValueCoding
\f0\fs26 \cf0  and 
\f2\fs26\fsmilli13390 \cf6 NSKeyValueObserving
\f0\fs26 \cf0  informal protocols. But to get all the benefits 
\f2\fs26\fsmilli13390 \cf6 NSController
\f0\fs26 \cf0  and its subclasses give you, it is better to make bindings through mediating controllers.\cb4 \
\cb2 Coordinating controllers centralize communication and control logic in an application by:\cb4 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls3\ilvl0\cf0 \cb2 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Maintaining outlets to model and view objects (outlets are instance variables that hold connections or references to other objects)\cb4 \
\ls3\ilvl0\cb2 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Responding to user manipulations of view objects through target-action (see \cf7 The Target-Action Mechanism\cf0 )\cb4 \
\ls3\ilvl0\cb2 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Acting as a delegate for messages sent by framework objects (see \cf7 Delegation\cf0 )\cb4 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb2 You usually make all of the above connections\'97outlets, target-action, and delegates\'97in Interface Builder, which archives them in the application\'92s nib file.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Further Reading:
\f0\b0 \'a0See \cf7 The Model-View-Controller Design Pattern\cf0  for a discussion of mediating controllers, coordinating controllers, and design decisions related to controllers. a target="_self" Cocoa Bindings Programming Topics/a describes the mediating controller classes in detail.\cb4 \
\
\pard\pardeftab720\partightenfactor0

\fs32\fsmilli16250 \cf0 \cb2 View Controllers in UIKit\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 Applications running in iOS frequently use a modal and navigational user-interface design for presenting screen-size chunks of the application\'92s data model. An application may have a navigation bar and a toolbar, and between these objects is the current view of application data. Users can tap buttons on the toolbar to select a mode, tap buttons on the navigation bar, and tap controls in the current view to traverse a hierarchy of model (data) objects; at each level the central view presents more detail. At the end of this hierarchy is often an item that the user can inspect or edit. (An application, of course, is free to use just a navigation bar or just a toolbar.)\cb4 \
\cb2 View controllers\'97that inherit from 
\f2\fs26\fsmilli13390 \cf6 a target="_self" UIViewController/a
\f0\fs26 \cf0 \'97are central to this design. 
\f2\fs26\fsmilli13390 \cf6 UIViewController
\f0\fs26 \cf0  is an abstract class that you can subclass to manage a particular view. The UIKit framework also provides 
\f2\fs26\fsmilli13390 \cf6 UIViewController
\f0\fs26 \cf0  subclasses for managing navigation bar and toolbar objects: 
\f2\fs26\fsmilli13390 \cf6 a target="_self" UINavigationController/a
\f0\fs26 \cf0  and 
\f2\fs26\fsmilli13390 \cf6 a target="_self" UITabBarController/a
\f0\fs26 \cf0 . As depicted in Figure 4-4, a tab-bar controller can manage a number of navigation controllers, which in turn can manage one or more view controllers, each with its associated view object. In addition to managing views (including overlay views), a view controller specifies the buttons and titles that are displayed in the navigation bar.\cb4 \
\cb2 To learn more about view controllers, see a target="_self" View Controller Programming Guide for iOS/a.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Figure 4-4
\f0\b0 \'a0\'a0View controllers in UIKit\cb4 \
\pard\pardeftab720\partightenfactor0
\cf0 {{\NeXTGraphic uictlr_object_diagram.jpg \width9220 \height7480 \noorient
}¬}\pard\pardeftab720\partightenfactor0
\cf0 \
\pard\pardeftab720\partightenfactor0

\fs37\fsmilli18850 \cf0 \cb2 Memento\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 The Memento pattern captures and externalizes an object\'92s internal state\'97without violating encapsulation\'97so that the object can be restored to this state later. The Memento pattern keeps the important state of a key object external from that object to maintain cohesion.\cb4 \
\pard\pardeftab720\partightenfactor0

\fs32\fsmilli16250 \cf0 \cb2 Archiving\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 Archiving converts the objects in a program, along with those objects\'92 properties (attributes and relationships) into an archive that can be stored in the file system or transmitted between processes or across a network. The archive captures the object graph of a program as an architecture-independent stream of bytes that preserves the identity of the objects and the relationships among them. Because an object\'92s type is stored along with its data, an object decoded from a stream of bytes is normally instantiated using the same class of the object that was originally encoded.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Uses and Limitations\cb4 \
\pard\pardeftab720\partightenfactor0

\f0\b0 \cf0 \cb2 Generally, you want to archive those objects in your program whose state you want to preserve. Model objects almost always fall into this category. You write an object to an archive by encoding it, and you read that object from an archive by decoding it. Encoding and decoding are operations that you perform using an {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSCoder/Description.html#//apple_ref/occ/cl/NSCoder"}}{\fldrslt 
\f2\fs26\fsmilli13390 \cf7 NSCoder}} object, preferably using the keyed archiving technique (requiring you to invoke methods of the 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSKeyedArchiver/a
\f0\fs26 \cf0  and 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSKeyedUnarchiver/a
\f0\fs26 \cf0  classes). The object being encoded and decoded must conform to the {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Protocols/NSCoding/Description.html#//apple_ref/occ/intf/NSCoding"}}{\fldrslt 
\f2\fs26\fsmilli13390 \cf7 NSCoding}} protocol; the methods of this protocol are invoked during archiving.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Further Reading:
\f0\b0 \'a0See a target="_self" Archives and Serializations Programming Guide/a for further information about archiving.\cb4 \
\
\pard\pardeftab720\partightenfactor0

\fs32\fsmilli16250 \cf0 \cb2 Property List Serialization\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 A property list is a simple, structured serialization of an object graph that uses only objects of the following classes: {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSDictionaryClassClstr/Description.html#//apple_ref/occ/cl/NSDictionary"}}{\fldrslt 
\f2\fs26\fsmilli13390 \cf7 NSDictionary}}, {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSArrayClassCluster/Description.html#//apple_ref/occ/cl/NSArray"}}{\fldrslt 
\f2\fs26\fsmilli13390 \cf7 NSArray}}, {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSStringClassCluster/Description.html#//apple_ref/occ/cl/NSString"}}{\fldrslt 
\f2\fs26\fsmilli13390 \cf7 NSString}}, {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSDataClassCluster/Description.html#//apple_ref/occ/cl/NSData"}}{\fldrslt 
\f2\fs26\fsmilli13390 \cf7 NSData}}, {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSDateClassCluster/Description.html#//apple_ref/occ/cl/NSDate"}}{\fldrslt 
\f2\fs26\fsmilli13390 \cf7 NSDate}}, and {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSNumber/Description.html#//apple_ref/occ/cl/NSNumber"}}{\fldrslt 
\f2\fs26\fsmilli13390 \cf7 NSNumber}}. These objects are commonly referred to as property list objects. Several Cocoa framework classes offer methods to serialize these property list objects and define special formats for the data stream recording the contents of the objects and their hierarchical relationship. The 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSPropertyListSerialization/a
\f0\fs26 \cf0  class provides class methods that serialize property list objects to and from an XML format or an optimized binary format.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Uses and Limitations\cb4 \
\pard\pardeftab720\partightenfactor0

\f0\b0 \cf0 \cb2 If the objects in an object graph are simple, property list serialization is a flexible, portable, and adequate means to capture and externalize an object and its state. However, this form of serialization has its limitations. It does not preserve the full class identity of objects, only the general kind (array, dictionary, string, and so on). Thus an object restored from a property list might be of a different class than its original class. This is especially an issue when the mutability of an object can vary. Property list serialization also doesn\'92t keep track of objects that are referenced multiple times in an object, potentially resulting in multiple instances upon deserialization that was a single instance in the original object graph.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Further Reading:
\f0\b0 \'a0See a target="_self" Archives and Serializations Programming Guide/a for further information on property list serialization.\cb4 \
\
\pard\pardeftab720\partightenfactor0

\fs32\fsmilli16250 \cf0 \cb2 Core Data\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 Core Data is a Cocoa framework that defines an architecture for managing object graphs and making them persistent. It is this second capability\'97object persistence\'97that makes Core Data an adaptation of the Memento pattern.\cb4 \
\cb2 In the Core Data architecture, a central object called the managed object context manages the various model objects in an application's object graph. Below the managed object context is the persistence stack for that object graph\'97a collection of framework objects that mediate between the model objects and external data stores, such as XML files or relational databases. The persistence-stack objects map between data in the store and corresponding objects in the managed data context and, when there are multiple data stores, present them to the managed object context as a single aggregate store.\cb4 \
\cb2 The design of Core Data is also heavily influenced by the Model-View-Controller and object modeling patterns.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Uses and Limitations\cb4 \
\pard\pardeftab720\partightenfactor0

\f0\b0 \cf0 \cb2 Core Data is particularly useful in the development of enterprise applications where complex graphs of model objects must be defined, managed, and transparently archived and unarchived to and from data stores. The Xcode development environment includes project templates and design tools that reduce the programming effort required to create the two general types of Core Data applications, those that are document-based and those that are not document-based. The Interface Builder application also includes configurable Core Data framework objects in its library.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Further Reading:
\f0\b0 \'a0To learn more about Core Data, read a target="_self" Core Data Programming Guide/a. The tutorials a target="_self" NSPersistentDocument Core Data Tutorial/a and {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/Cocoa/Conceptual/CoreDataUtilityTutorial/Articles/01_introduction.html#//apple_ref/doc/uid/TP40001800"}}{\fldrslt \cf7 Core Data Utility Tutorial}} step you through the basic procedure for creating document-based and non\'96document-based Core Data applications.\cb4 \
\
\pard\pardeftab720\partightenfactor0

\fs37\fsmilli18850 \cf0 \cb2 Observer\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 The Observer design pattern defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically. The Observer pattern is essentially a publish-and-subscribe model in which the subject and its observers are loosely coupled. Communication can take place between the observing and observed objects without either needing to know much about the other.\cb4 \
\pard\pardeftab720\partightenfactor0

\fs32\fsmilli16250 \cf0 \cb2 Notifications\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 The notification mechanism of Cocoa implements one-to-many broadcast of messages based on the Observer pattern. Objects in a program add themselves or other objects to a list of observers of one or more notifications, each of which is identified by a global string (the notification name). The object that wants to notify other objects\'97the observed object\'97creates a notification object and posts it to a notification center. The notification center determines the observers of a particular notification and sends the notification to them via a message. The methods invoked by the notification message must conform to a certain single-parameter signature. The parameter of the method is the notification object, which contains the notification name, the observed object, and a dictionary containing any supplemental information.\cb4 \
\cb2 Posting a notification is a synchronous procedure. The posting object doesn't regain control until the notification center has broadcast the notification to all observers. For asynchronous behavior, you can put the notification in a notification queue; control returns immediately to the posting object and the notification center broadcasts the notification when it reaches the top of the queue.\cb4 \
\cb2 Regular notifications\'97that is, those broadcast by the notification center\'97are intraprocess only. If you want to broadcast notifications to other processes, you can use the distributed notification center and its related API.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Uses and Limitations\cb4 \
\pard\pardeftab720\partightenfactor0

\f0\b0 \cf0 \cb2 You can use notifications for a variety of reasons. For example, you could broadcast a notification to change how user-interface elements display information based on a certain event elsewhere in the program. Or you could use notifications as a way to ensure that objects in a document save their state before the document window is closed. The general purpose of notifications is to inform other objects of program events so they can respond appropriately.\cb4 \
\cb2 But objects receiving notifications can react only after the event has occurred. This is a significant difference from delegation. The delegate is given a chance to reject or modify the operation proposed by the delegating object. Observing objects, on the other hand, cannot directly affect an impending operation.\cb4 \
\cb2 The notification classes are 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSNotification/a
\f0\fs26 \cf0  (for notification objects), {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSNotificationCenter/Description.html#//apple_ref/occ/cl/NSNotificationCenter"}}{\fldrslt 
\f2\fs26\fsmilli13390 \cf7 NSNotificationCenter}} (to post notifications and add observers), {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSNotificationQueue/Description.html#//apple_ref/occ/cl/NSNotificationQueue"}}{\fldrslt 
\f2\fs26\fsmilli13390 \cf7 NSNotificationQueue}} (to enqueue notifications), and 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSDistributedNotificationCenter/a
\f0\fs26 \cf0 . Many Cocoa framework classes publish and post notifications that any object can observe.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Further Reading:
\f0\b0 \'a0{\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/Cocoa/Conceptual/CocoaFundamentals/CommunicatingWithObjects/CommunicateWithObjects.html#//apple_ref/doc/uid/TP40002974-CH7-SW7"}}{\fldrslt \cf7 Notifications}} describes the notification mechanism in greater detail and offers guidelines for its use.\cb4 \
\
\pard\pardeftab720\partightenfactor0

\fs32\fsmilli16250 \cf0 \cb2 Key-Value Observing\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 Key-value observing is a mechanism that allows objects to be notified of changes to specific properties of other objects. It is based on the 
\f2\fs26\fsmilli13390 \cf6 NSKeyValueObserving
\f0\fs26 \cf0  informal protocol. Observed properties can be simple attributes, to-one relationships, or to-many relationships. In the context of the Model-View-Controller pattern, key-value observing is especially important because it enables view objects to observe\'97via the controller layer\'97changes in model objects. It is thus an essential component of the Cocoa bindings technology (see \cf7 Controller Classes in the AppKit Framework\cf0 ).\cb4 \
\cb2 Cocoa provides a default \'93automatic\'94 implementation of many 
\f2\fs26\fsmilli13390 \cf6 NSKeyValueObserving
\f0\fs26 \cf0  methods that gives all complying objects a property-observing capability.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Uses and Limitations\cb4 \
\pard\pardeftab720\partightenfactor0

\f0\b0 \cf0 \cb2 Key-value observing is similar to the notification mechanism but is different in important respects. In key-value observing there is no central object that provides change notification for all observers. Instead, notifications of changes are directly transmitted to observing objects. Key-value observing is also directly tied to the values of specific object properties. The notification mechanism, on the other hand, is more broadly concerned with program events.\cb4 \
\cb2 Objects that participate in key-value observing (KVO) must be KVO-compliant\'97that is, comply with certain requirements. For automatic observing, this requires compliance with the requirements of key-value coding (KVC-compliance) and using the KVC-compliance methods (that is, accessor methods). Key-value coding is a related mechanism (based on a related informal protocol) for automatically getting and setting the values of object properties.\cb4 \
\cb2 You can refine KVO notifications by disabling automatic observer notifications and implementing manual notifications using the methods of the 
\f2\fs26\fsmilli13390 \cf6 NSKeyValueObserving
\f0\fs26 \cf0  informal protocol and associated categories.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Further Reading:
\f0\b0 \'a0See a target="_self" Key-Value Observing Programming Guide/a to learn more about the mechanism and underlying protocol. Also see the related documents a target="_self" Key-Value Coding Programming Guide/a and a target="_self" Cocoa Bindings Programming Topics/a.\cb4 \
\
\pard\pardeftab720\partightenfactor0

\fs37\fsmilli18850 \cf0 \cb2 Proxy\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 The Proxy design pattern provides a surrogate, or placeholder, for another object in order to control access to that other object. You use this pattern to create a representative, or proxy, object that controls access to another object, which may be remote, expensive to create, or in need of securing. This pattern is structurally similar to the Decorator pattern but it serves a different purpose; Decorator adds behavior to an object whereas Proxy controls access to an object.\cb4 \
\pard\pardeftab720\partightenfactor0

\fs32\fsmilli16250 \cf0 \cb2 NSProxy\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 The {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSProxy/Description.html#//apple_ref/occ/cl/NSProxy"}}{\fldrslt 
\f2\fs26\fsmilli13390 \cf7 NSProxy}} class defines the interface for objects that act as surrogates for other objects, even for objects that don\'92t yet exist. A proxy object typically forwards a message sent to it to the object that it represents, but it can also respond to the message by loading the represented object or transforming itself into it. Although 
\f2\fs26\fsmilli13390 \cf6 NSProxy
\f0\fs26 \cf0  is an abstract class, it implements the {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Protocols/NSObject/Description.html#//apple_ref/occ/intf/NSObject"}}{\fldrslt 
\f2\fs26\fsmilli13390 \cf7 NSObject}} protocol and other fundamental methods expected of a root object; it is, in fact, the root class of a hierarchy just as the 
\f2\fs26\fsmilli13390 \cf6 NSObject
\f0\fs26 \cf0  class is.\cb4 \
\cb2 Concrete subclasses of 
\f2\fs26\fsmilli13390 \cf6 NSProxy
\f0\fs26 \cf0  can accomplish the stated goals of the Proxy pattern, such as lazy instantiation of expensive objects or acting as sentry objects for security. 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSDistantObject/a
\f0\fs26 \cf0 , a concrete subclass of 
\f2\fs26\fsmilli13390 \cf6 NSProxy
\f0\fs26 \cf0  in the Foundation framework, implements a remote proxy for transparent distributed messaging. 
\f2\fs26\fsmilli13390 \cf6 NSDistantObject
\f0\fs26 \cf0  objects are part of the architecture for distributed objects. By acting as proxies for objects in other processes or threads, they help to enable communication between objects in those threads or processes.\cb4 \
\pard\pardeftab720\partightenfactor0

\f2\fs26\fsmilli13390 \cf6 \cb2 a target="_self" NSInvocation/a
\f0\fs26 \cf0  objects, which are an adaptation of the Command pattern, are also part of the distributed objects architecture (see \cf7 Invocation Objects\cf0 ).\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Uses and Limitations\cb4 \
\pard\pardeftab720\partightenfactor0

\f0\b0 \cf0 \cb2 Cocoa employs 
\f2\fs26\fsmilli13390 \cf6 NSProxy
\f0\fs26 \cf0  objects only in distributed objects. The 
\f2\fs26\fsmilli13390 \cf6 NSProxy
\f0\fs26 \cf0  objects are specifically instances of the concrete subclasses 
\f2\fs26\fsmilli13390 \cf6 NSDistantObject
\f0\fs26 \cf0  and {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSProtocolChecker/Description.html#//apple_ref/occ/cl/NSProtocolChecker"}}{\fldrslt 
\f2\fs26\fsmilli13390 \cf7 NSProtocolChecker}}. You can use distributed objects not only for interprocess messaging (on the same or different computers) but you can also use it to implement distributed computing or parallel processing. If you want to use proxy objects for other purposes, such as the creation of expensive resources or security, you have to implement your own concrete subclass of 
\f2\fs26\fsmilli13390 \cf6 NSProxy
\f0\fs26 \cf0 .\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Further Reading:
\f0\b0 \'a0To learn more about Cocoa proxy objects and the role they play in distributed messaging, read a target="_self" Distributed Objects Programming Topics/a.\cb4 \
\
\pard\pardeftab720\partightenfactor0

\fs37\fsmilli18850 \cf0 \cb2 Receptionist\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 The Receptionist design pattern addresses the general problem of redirecting an event occurring in one execution context of an application to another execution context for handling. It is a hybrid pattern. Although it doesn\'92t appear in the \'93Gang of Four\'94 book, it combines elements of the Command, Memo, and Proxy design patterns described in that book. It is also a variant of the Trampoline pattern (which also doesn\'92t appear in the book); in this pattern, an event initially is received by a trampoline object, so-called because it immediately bounces, or redirects, the event to a target object for handling.\cb4 \
\cb2 You can adopt the Receptionist design pattern whenever you need to bounce off work to another execution context for handling. When you observe a notification, or implement a block handler, or respond to an action message and you want to ensure that your code executes in the appropriate execution context, you can implement the Receptionist pattern to redirect the work that must be done to that execution context. With the Receptionist pattern, you might even perform some filtering or coalescing of the incoming data before you bounce off a task to process the data. For example, you could collect data into batches, and then at intervals dispatch those batches elsewhere for processing.\cb4 \
\cb2 One common situation where the Receptionist pattern is useful is key-value observing. In key-value observing, changes to the value of an model object\'92s property are communicated to observers via KVO notifications. However, changes to a model object can occur on a background thread. This results in a thread mismatch, because changes to a model object\'92s state typically result in updates to the user interface, and these must occur on the main thread. In this case, you want to redirect the KVO notifications to the main thread. where the updates to an application\'92s user interface can occur.\cb4 \
\pard\pardeftab720\partightenfactor0

\fs32\fsmilli16250 \cf0 \cb2 The Receptionist Design Pattern in Practice\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 A KVO notification invokes the 
\f2\fs26\fsmilli13390 \cf6 a target="_self" observeValueForKeyPath:ofObject:change:context:/a
\f0\fs26 \cf0  method implemented by an observer. If the change to the property occurs on a secondary thread, the 
\f2\fs26\fsmilli13390 \cf6 observeValueForKeyPath:ofObject:change:context:
\f0\fs26 \cf0  code executes on that same thread. There the central object in this pattern, the receptionist, acts as a thread intermediary. As Figure 4-5 illustrates, a receptionist object is assigned as the observer of a model object\'92s property. The receptionist implements 
\f2\fs26\fsmilli13390 \cf6 observeValueForKeyPath:ofObject:change:context:
\f0\fs26 \cf0  to redirect the notification received on a secondary thread to another execution context\'97the main operation queue, in this case. When the property changes, the receptionist receives a KVO notification. The receptionist immediately adds a block operation to the main operation queue; the block contains code\'97specified by the client\'97that updates the user interface appropriately.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Figure 4-5
\f0\b0 \'a0\'a0Bouncing KVO updates to the main operation queue\cb4 \
\pard\pardeftab720\partightenfactor0
\cf0 {{\NeXTGraphic receptionist.jpg \width10060 \height8920 \noorient
}¬}\pard\pardeftab720\partightenfactor0
\cf0 \
\cb2 You define a receptionist class so that it has the elements it needs to add itself as an observer of a property and then convert a KVO notification into an update task. Thus it must know what object it\'92s observing, the property of the object that it\'92s observing, what update task to execute, and what queue to execute it on. Listing 4-1 shows the initial declaration of the 
\f2\fs26\fsmilli13390 \cf6 RCReceptionist
\f0\fs26 \cf0  class and its instance variables.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Listing 4-1
\f0\b0 \'a0\'a0Declaring the receptionist class\cb4 \

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat8 \trbrdrt\brdrs\brdrw20\brdrcf9 \trbrdrl\brdrs\brdrw20\brdrcf9 \trbrdrr\brdrs\brdrw20\brdrcf9 \tapadb80 
\clvertalc \clshdrawnil \clwWidth26301\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt119 \clpadl119 \clpadb119 \clpadr119 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f2\fs24\fsmilli12275 \cf6 \cb2 @interface RCReceptionist : NSObject \{\cb4 \
\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat8 \trbrdrl\brdrs\brdrw20\brdrcf9 \trbrdrr\brdrs\brdrw20\brdrcf9 \tapadb80 
\clvertalc \clshdrawnil \clwWidth26301\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt119 \clpadl119 \clpadb119 \clpadr119 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0
\cf6 \cb2     id observedObject;\cb4 \
\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat8 \trbrdrl\brdrs\brdrw20\brdrcf9 \trbrdrr\brdrs\brdrw20\brdrcf9 \tapadb80 
\clvertalc \clshdrawnil \clwWidth26301\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt119 \clpadl119 \clpadb119 \clpadr119 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0
\cf6 \cb2     NSString *observedKeyPath;\cb4 \
\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat8 \trbrdrl\brdrs\brdrw20\brdrcf9 \trbrdrr\brdrs\brdrw20\brdrcf9 \tapadb80 
\clvertalc \clshdrawnil \clwWidth26301\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt119 \clpadl119 \clpadb119 \clpadr119 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0
\cf6 \cb2     RCTaskBlock task;\cb4 \
\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat8 \trbrdrl\brdrs\brdrw20\brdrcf9 \trbrdrr\brdrs\brdrw20\brdrcf9 \tapadb80 
\clvertalc \clshdrawnil \clwWidth26301\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt119 \clpadl119 \clpadb119 \clpadr119 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0
\cf6 \cb2     NSOperationQueue *queue;\cb4 \
\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat8 \trbrdrl\brdrs\brdrw20\brdrcf9 \trbrdrb\brdrs\brdrw20\brdrcf9 \trbrdrr\brdrs\brdrw20\brdrcf9 \tapadb80 
\clvertalc \clshdrawnil \clwWidth26301\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt119 \clpadl119 \clpadb119 \clpadr119 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0
\cf6 \cb2 \}\cb4 \
\cell \lastrow\row
\pard\pardeftab720\partightenfactor0

\f0\fs26 \cf0 \cb2 The 
\f2\fs26\fsmilli13390 \cf6 RCTaskBlock
\f0\fs26 \cf0  instance variable is a block object of the following declared type:\cb4 \

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat8 \trbrdrt\brdrs\brdrw20\brdrcf9 \trbrdrl\brdrs\brdrw20\brdrcf9 \trbrdrb\brdrs\brdrw20\brdrcf9 \trbrdrr\brdrs\brdrw20\brdrcf9 \tapadb80 
\clvertalc \clshdrawnil \clwWidth26301\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt119 \clpadl119 \clpadb119 \clpadr119 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f2\fs24\fsmilli12275 \cf6 \cb2 typedef void (^RCTaskBlock)(NSString *keyPath, id object, NSDictionary *change);\cb4 \
\cell \lastrow\row
\pard\pardeftab720\partightenfactor0

\f0\fs26 \cf0 \cb2 These parameters are similar to those of the 
\f2\fs26\fsmilli13390 \cf6 observeValueForKeyPath:ofObject:change:context:
\f0\fs26 \cf0  method. Next, the parameter class declares a single class factory method in which an 
\f2\fs26\fsmilli13390 \cf6 RCTaskBlock
\f0\fs26 \cf0  object is a parameter:\cb4 \

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat8 \trbrdrt\brdrs\brdrw20\brdrcf9 \trbrdrl\brdrs\brdrw20\brdrcf9 \trbrdrr\brdrs\brdrw20\brdrcf9 \tapadb80 
\clvertalc \clshdrawnil \clwWidth26301\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt119 \clpadl119 \clpadb119 \clpadr119 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f2\fs24\fsmilli12275 \cf6 \cb2 + (id)receptionistForKeyPath:(NSString *)path\cb4 \
\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat8 \trbrdrl\brdrs\brdrw20\brdrcf9 \trbrdrr\brdrs\brdrw20\brdrcf9 \tapadb80 
\clvertalc \clshdrawnil \clwWidth26301\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt119 \clpadl119 \clpadb119 \clpadr119 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0
\cf6 \cb2         object:(id)obj\cb4 \
\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat8 \trbrdrl\brdrs\brdrw20\brdrcf9 \trbrdrr\brdrs\brdrw20\brdrcf9 \tapadb80 
\clvertalc \clshdrawnil \clwWidth26301\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt119 \clpadl119 \clpadb119 \clpadr119 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0
\cf6 \cb2          queue:(NSOperationQueue *)queue\cb4 \
\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat8 \trbrdrl\brdrs\brdrw20\brdrcf9 \trbrdrb\brdrs\brdrw20\brdrcf9 \trbrdrr\brdrs\brdrw20\brdrcf9 \tapadb80 
\clvertalc \clshdrawnil \clwWidth26301\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt119 \clpadl119 \clpadb119 \clpadr119 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0
\cf6 \cb2           task:(RCTaskBlock)task;\cb4 \
\cell \lastrow\row
\pard\pardeftab720\partightenfactor0

\f0\fs26 \cf0 \cb2 It implements this method to assign the passed-in value to instance variables of the created receptionist object and to add that object as an observer of the model object\'92s property, as shown in Listing 4-2.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Listing 4-2
\f0\b0 \'a0\'a0The class factory method for creating a receptionist object\cb4 \

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat8 \trbrdrt\brdrs\brdrw20\brdrcf9 \trbrdrl\brdrs\brdrw20\brdrcf9 \trbrdrr\brdrs\brdrw20\brdrcf9 \tapadb80 
\clvertalc \clshdrawnil \clwWidth26301\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt119 \clpadl119 \clpadb119 \clpadr119 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f2\fs24\fsmilli12275 \cf6 \cb2 + (id)receptionistForKeyPath:(NSString *)path object:(id)obj queue:(NSOperationQueue *)queue task:(RCTaskBlock)task \{\cb4 \
\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat8 \trbrdrl\brdrs\brdrw20\brdrcf9 \trbrdrr\brdrs\brdrw20\brdrcf9 \tapadb80 
\clvertalc \clshdrawnil \clwWidth26301\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt119 \clpadl119 \clpadb119 \clpadr119 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0
\cf6 \cb2     RCReceptionist *receptionist = [RCReceptionist new];\cb4 \
\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat8 \trbrdrl\brdrs\brdrw20\brdrcf9 \trbrdrr\brdrs\brdrw20\brdrcf9 \tapadb80 
\clvertalc \clshdrawnil \clwWidth26301\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt119 \clpadl119 \clpadb119 \clpadr119 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0
\cf6 \cb2     receptionist->task = [task copy];\cb4 \
\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat8 \trbrdrl\brdrs\brdrw20\brdrcf9 \trbrdrr\brdrs\brdrw20\brdrcf9 \tapadb80 
\clvertalc \clshdrawnil \clwWidth26301\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt119 \clpadl119 \clpadb119 \clpadr119 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0
\cf6 \cb2     receptionist->observedKeyPath = [path copy];\cb4 \
\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat8 \trbrdrl\brdrs\brdrw20\brdrcf9 \trbrdrr\brdrs\brdrw20\brdrcf9 \tapadb80 
\clvertalc \clshdrawnil \clwWidth26301\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt119 \clpadl119 \clpadb119 \clpadr119 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0
\cf6 \cb2     receptionist->observedObject = [obj retain];\cb4 \
\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat8 \trbrdrl\brdrs\brdrw20\brdrcf9 \trbrdrr\brdrs\brdrw20\brdrcf9 \tapadb80 
\clvertalc \clshdrawnil \clwWidth26301\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt119 \clpadl119 \clpadb119 \clpadr119 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0
\cf6 \cb2     receptionist->queue = [queue retain];\cb4 \
\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat8 \trbrdrl\brdrs\brdrw20\brdrcf9 \trbrdrr\brdrs\brdrw20\brdrcf9 \tapadb80 
\clvertalc \clshdrawnil \clwWidth26301\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt119 \clpadl119 \clpadb119 \clpadr119 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0
\cf6 \cb2     [obj addObserver:receptionist forKeyPath:path\cb4 \
\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat8 \trbrdrl\brdrs\brdrw20\brdrcf9 \trbrdrr\brdrs\brdrw20\brdrcf9 \tapadb80 
\clvertalc \clshdrawnil \clwWidth26301\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt119 \clpadl119 \clpadb119 \clpadr119 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0
\cf6 \cb2              options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:0];\cb4 \
\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat8 \trbrdrl\brdrs\brdrw20\brdrcf9 \trbrdrr\brdrs\brdrw20\brdrcf9 \tapadb80 
\clvertalc \clshdrawnil \clwWidth26301\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt119 \clpadl119 \clpadb119 \clpadr119 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0
\cf6 \cb2     return [receptionist autorelease];\cb4 \
\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat8 \trbrdrl\brdrs\brdrw20\brdrcf9 \trbrdrb\brdrs\brdrw20\brdrcf9 \trbrdrr\brdrs\brdrw20\brdrcf9 \tapadb80 
\clvertalc \clshdrawnil \clwWidth26301\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt119 \clpadl119 \clpadb119 \clpadr119 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0
\cf6 \cb2 \}\cb4 \
\cell \lastrow\row
\pard\pardeftab720\partightenfactor0

\f0\fs26 \cf0 \cb2 Note that the code copies the block object instead of retaining it. Because the block was probably created on the stack, it must be copied to the heap so it exists in memory when the KVO notification is delivered.\cb4 \
\cb2 Finally, the parameter class implements the 
\f2\fs26\fsmilli13390 \cf6 a target="_self" observeValueForKeyPath:ofObject:change:context:/a
\f0\fs26 \cf0  method. The implementation (see Listing 4-3) is simple.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Listing 4-3
\f0\b0 \'a0\'a0Handling the KVO notification\cb4 \

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat8 \trbrdrt\brdrs\brdrw20\brdrcf9 \trbrdrl\brdrs\brdrw20\brdrcf9 \trbrdrr\brdrs\brdrw20\brdrcf9 \tapadb80 
\clvertalc \clshdrawnil \clwWidth26301\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt119 \clpadl119 \clpadb119 \clpadr119 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f2\fs24\fsmilli12275 \cf6 \cb2 - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object\cb4 \
\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat8 \trbrdrl\brdrs\brdrw20\brdrcf9 \trbrdrr\brdrs\brdrw20\brdrcf9 \tapadb80 
\clvertalc \clshdrawnil \clwWidth26301\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt119 \clpadl119 \clpadb119 \clpadr119 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0
\cf6 \cb2         change:(NSDictionary *)change context:(void *)context \{\cb4 \
\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat8 \trbrdrl\brdrs\brdrw20\brdrcf9 \trbrdrr\brdrs\brdrw20\brdrcf9 \tapadb80 
\clvertalc \clshdrawnil \clwWidth26301\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt119 \clpadl119 \clpadb119 \clpadr119 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0
\cf6 \cb2     [queue addOperationWithBlock:^\{\cb4 \
\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat8 \trbrdrl\brdrs\brdrw20\brdrcf9 \trbrdrr\brdrs\brdrw20\brdrcf9 \tapadb80 
\clvertalc \clshdrawnil \clwWidth26301\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt119 \clpadl119 \clpadb119 \clpadr119 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0
\cf6 \cb2         task(keyPath, object, change);\cb4 \
\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat8 \trbrdrl\brdrs\brdrw20\brdrcf9 \trbrdrr\brdrs\brdrw20\brdrcf9 \tapadb80 
\clvertalc \clshdrawnil \clwWidth26301\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt119 \clpadl119 \clpadb119 \clpadr119 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0
\cf6 \cb2     \}];\cb4 \
\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat8 \trbrdrl\brdrs\brdrw20\brdrcf9 \trbrdrb\brdrs\brdrw20\brdrcf9 \trbrdrr\brdrs\brdrw20\brdrcf9 \tapadb80 
\clvertalc \clshdrawnil \clwWidth26301\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt119 \clpadl119 \clpadb119 \clpadr119 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0
\cf6 \cb2 \}\cb4 \
\cell \lastrow\row
\pard\pardeftab720\partightenfactor0

\f0\fs26 \cf0 \cb2 This code simply enqueues the task onto the given operation queue, passing the task block the observed object, the key path for the changed property, and the dictionary containing the new value. The task is encapsulated in an 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSBlockOperation/a
\f0\fs26 \cf0  object that executes the task on the queue.\cb4 \
\cb2 The client object supplies the block code that updates the user interface when it creates a receptionist object, as shown in Listing 4-4. Note that when it creates the receptionist object, the client passes in the operation queue on which the block is to be executed, in this case the main operation queue.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Listing 4-4
\f0\b0 \'a0\'a0Creating a receptionist object\cb4 \

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat8 \trbrdrt\brdrs\brdrw20\brdrcf9 \trbrdrl\brdrs\brdrw20\brdrcf9 \trbrdrr\brdrs\brdrw20\brdrcf9 \tapadb80 
\clvertalc \clshdrawnil \clwWidth26301\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt119 \clpadl119 \clpadb119 \clpadr119 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f2\fs24\fsmilli12275 \cf6 \cb2         RCReceptionist *receptionist = [RCReceptionist receptionistForKeyPath:@"value" object:model queue:mainQueue task:^(NSString *keyPath, id object, NSDictionary *change) \{\cb4 \
\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat8 \trbrdrl\brdrs\brdrw20\brdrcf9 \trbrdrr\brdrs\brdrw20\brdrcf9 \tapadb80 
\clvertalc \clshdrawnil \clwWidth26301\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt119 \clpadl119 \clpadb119 \clpadr119 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0
\cf6 \cb2             NSView *viewForModel = [modelToViewMap objectForKey:model];\cb4 \
\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat8 \trbrdrl\brdrs\brdrw20\brdrcf9 \trbrdrr\brdrs\brdrw20\brdrcf9 \tapadb80 
\clvertalc \clshdrawnil \clwWidth26301\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt119 \clpadl119 \clpadb119 \clpadr119 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0
\cf6 \cb2             NSColor *newColor = [change objectForKey:NSKeyValueChangeNewKey];\cb4 \
\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat8 \trbrdrl\brdrs\brdrw20\brdrcf9 \trbrdrr\brdrs\brdrw20\brdrcf9 \tapadb80 
\clvertalc \clshdrawnil \clwWidth26301\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt119 \clpadl119 \clpadb119 \clpadr119 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0
\cf6 \cb2             [[[viewForModel subviews] objectAtIndex:0] setFillColor:newColor];\cb4 \
\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat8 \trbrdrl\brdrs\brdrw20\brdrcf9 \trbrdrb\brdrs\brdrw20\brdrcf9 \trbrdrr\brdrs\brdrw20\brdrcf9 \tapadb80 
\clvertalc \clshdrawnil \clwWidth26301\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt119 \clpadl119 \clpadb119 \clpadr119 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0
\cf6 \cb2         \}];\cb4 \
\cell \lastrow\row
\pard\pardeftab720\partightenfactor0

\f0\fs37\fsmilli18850 \cf0 \cb2 Singleton\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 The Singleton design pattern ensures a class only has one instance, and provides a global point of access to it. The class keeps track of its sole instance and ensures that no other instance can be created. Singleton classes are appropriate for situations where it makes sense for a single object to provide access to a global resource.\cb4 \
\pard\pardeftab720\partightenfactor0

\fs32\fsmilli16250 \cf0 \cb2 Framework Classes\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 Several Cocoa framework classes are singletons. They include 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSFileManager/a
\f0\fs26 \cf0 , 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSWorkspace/a
\f0\fs26 \cf0 , 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSApplication/a
\f0\fs26 \cf0 , and, in UIKit, 
\f2\fs26\fsmilli13390 \cf6 a target="_self" UIApplication/a
\f0\fs26 \cf0 . A process is limited to one instance of these classes. When a client asks the class for an instance, it gets a shared instance, which is lazily created upon the first request.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Uses and Limitations\cb4 \
\pard\pardeftab720\partightenfactor0

\f0\b0 \cf0 \cb2 Using the shared instance returned by a singleton class is no different from using an instance of a nonsingleton class, except that you are prevented from copying, retaining, or releasing it (the related methods are reimplemented as null operations). You can create your own singleton classes if the situation warrants it.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Further Reading:
\f0\b0 \'a0{\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/Cocoa/Conceptual/CocoaFundamentals/CocoaObjects/CocoaObjects.html#//apple_ref/doc/uid/TP40002974-CH4-SW31"}}{\fldrslt \cf7 Cocoa Objects}} explains how to create a singleton class.\cb4 \
\
\pard\pardeftab720\partightenfactor0

\fs37\fsmilli18850 \cf0 \cb2 Template Method\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 The Template Method design pattern defines the skeleton of an algorithm in an operation, deferring some steps to subclasses. The Template Method pattern lets subclasses redefine certain steps of an algorithm without changing the algorithm\'92s structure.\cb4 \
\pard\pardeftab720\partightenfactor0

\fs32\fsmilli16250 \cf0 \cb2 Overridden Framework Methods\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 The Template Method pattern is a fundamental design of Cocoa, and indeed of object-oriented frameworks in general. The pattern in Cocoa lets custom components of a program hook themselves into an algorithm, but the framework components determine when and how they are needed. The programmatic interfaces of Cocoa classes often include methods that are meant to be overridden by subclasses. At runtime, the framework invokes these so-called generic methods at certain points in the task it is carrying out. The generic methods provide a structure for custom code to contribute program-specific behavior and data to the task being executed and coordinated by framework classes.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Uses and Limitations\cb4 \
\pard\pardeftab720\partightenfactor0

\f0\b0 \cf0 \cb2 To make use of the Cocoa adaptation of the Template Method pattern, you must create a subclass and override those methods that the framework invokes to insert application-specific input into the algorithm it is executing. If you are writing your own framework, you should probably include the pattern in the design.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Note:
\f0\b0 \'a0{\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/Cocoa/Conceptual/CocoaFundamentals/AddingBehaviortoaCocoaProgram/AddingBehaviorCocoa.html#//apple_ref/doc/uid/TP40002974-CH5-SW1"}}{\fldrslt \cf7 Adding Behavior to a Cocoa Program}} discusses the Cocoa adaptation of the Template Method pattern, especially in {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/Cocoa/Conceptual/CocoaFundamentals/AddingBehaviortoaCocoaProgram/AddingBehaviorCocoa.html#//apple_ref/doc/uid/TP40002974-CH5-SW19"}}{\fldrslt \cf7 Inheriting from a Cocoa Class}}.\cb4 \
\
\pard\pardeftab720\partightenfactor0

\fs32\fsmilli16250 \cf0 \cb2 The Document Architecture in OS X\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 The document architecture defined by the AppKit framework is a particular\'97and important\'97instance of the general design of overridden framework methods as an adaptation of the Template Method pattern. Cocoa applications that can create and manage multiple documents, each in its own window, are almost always based on the document architecture. In this architecture there are cooperating objects of three framework classes: 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSDocument/a
\f0\fs26 \cf0 , 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSWindowController/a
\f0\fs26 \cf0 , and 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSDocumentController/a
\f0\fs26 \cf0 . 
\f2\fs26\fsmilli13390 \cf6 NSDocument
\f0\fs26 \cf0  objects manage the model objects that represent the data of a document; upon user requests, they write that data to files and reload the data, recreating the model objects with it. 
\f2\fs26\fsmilli13390 \cf6 NSWindowController
\f0\fs26 \cf0  objects manage the user interface of particular documents. The 
\f2\fs26\fsmilli13390 \cf6 NSDocumentController
\f0\fs26 \cf0  object of a document-based application tracks and manages all open documents and otherwise coordinates the activities of the application. At runtime, each of these objects receives messages from AppKit requesting it to perform specific operations. The application developer must override many of the methods invoked by these messages to add application-specific behavior.\cb4 \
\cb2 The design of the document architecture of Cocoa is also heavily influenced by the Model-View-Controller pattern.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Uses and Limitations\cb4 \
\pard\pardeftab720\partightenfactor0

\f0\b0 \cf0 \cb2 You can create a project for a document-based Cocoa application by choosing the Cocoa Document-based Application template from the New Project dialog in Xcode. Then you must implement a custom subclass of 
\f2\fs26\fsmilli13390 \cf6 NSDocument
\f0\fs26 \cf0  and may choose to implement custom subclasses of 
\f2\fs26\fsmilli13390 \cf6 NSWindowController
\f0\fs26 \cf0  and 
\f2\fs26\fsmilli13390 \cf6 NSDocumentController
\f0\fs26 \cf0 . The AppKit framework provides much of the document-management logic of the application for you.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Note:
\f0\b0 \'a0 For the definitive documentation for this adaptation of the Template Method pattern, see a target="_self" Document-Based Applications Overview/a.\cb4 \
\
\pard\pardeftab720\partightenfactor0

\fs48\fsmilli24310 \cf5 \cb2 The Model-View-Controller Design Pattern\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 The Model-View-Controller design pattern (MVC) is quite old. Variations of it have been around at least since the early days of Smalltalk. It is a high-level pattern in that it concerns itself with the global architecture of an application and classifies objects according to the general roles they play in an application. It is also a compound pattern in that it comprises several, more elemental patterns.\cb4 \
\cb2 Object-oriented programs benefit in several ways by adapting the MVC design pattern for their designs. Many objects in these programs tend to be more reusable and their interfaces tend to be better defined. The programs overall are more adaptable to changing requirements\'97in other words, they are more easily extensible than programs that are not based on MVC. Moreover, many technologies and architectures in Cocoa\'97such as bindings, the document architecture, and scriptability\'97are based on MVC and require that your custom objects play one of the roles defined by MVC.\cb4 \
\pard\pardeftab720\partightenfactor0

\fs37\fsmilli18850 \cf0 \cb2 Roles and Relationships of MVC Objects\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 The MVC design pattern considers there to be three types of objects: model objects, view objects, and controller objects. The MVC pattern defines the roles that these types of objects play in the application and their lines of communication. When designing an application, a major step is choosing\'97or creating custom classes for\'97objects that fall into one of these three groups. Each of the three types of objects is separated from the others by abstract boundaries and communicates with objects of the other types across those boundaries.\cb4 \
\pard\pardeftab720\partightenfactor0

\fs32\fsmilli16250 \cf0 \cb2 Model Objects Encapsulate Data and Basic Behaviors\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 Model objects represent special knowledge and expertise. They hold an application\'92s data and define the logic that manipulates that data. A well-designed MVC application has all its important data encapsulated in model objects. Any data that is part of the persistent state of the application (whether that persistent state is stored in files or databases) should reside in the model objects once the data is loaded into the application. Because they represent knowledge and expertise related to a specific problem domain, they tend to be reusable.\cb4 \
\cb2 Ideally, a model object has no explicit connection to the user interface used to present and edit it. For example, if you have a model object that represents a person (say you are writing an address book), you might want to store a birthdate. That\'92s a good thing to store in your Person model object. However, storing a date format string or other information on how that date is to be presented is probably better off somewhere else.\cb4 \
\cb2 In practice, this separation is not always the best thing, and there is some room for flexibility here, but in general a model object should not be concerned with interface and presentation issues. One example where a bit of an exception is reasonable is a drawing application that has model objects that represent the graphics displayed. It makes sense for the graphic objects to know how to draw themselves because the main reason for their existence is to define a visual thing. But even in this case, the graphic objects should not rely on living in a particular view or any view at all, and they should not be in charge of knowing when to draw themselves. They should be asked to draw themselves by the view object that wants to present them.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Further Reading:
\f0\b0 \'a0a target="_self" Model Object Implementation Guide/a discusses the proper design and implementation of model objects.\cb4 \
\
\pard\pardeftab720\partightenfactor0

\fs32\fsmilli16250 \cf0 \cb2 View Objects Present Information to the User\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 A view object knows how to display, and might allow users to edit, the data from the application\'92s model. The view should not be responsible for storing the data it is displaying. (This does not mean the view never actually stores data it\'92s displaying, of course. A view can cache data or do similar tricks for performance reasons). A view object can be in charge of displaying just one part of a model object, or a whole model object, or even many different model objects. Views come in many different varieties.\cb4 \
\cb2 View objects tend to be reusable and configurable, and they provide consistency between applications. In Cocoa, the AppKit framework defines a large number of view objects and provides many of them in the Interface Builder library. By reusing the AppKit\'92s view objects, such as 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSButton/a
\f0\fs26 \cf0  objects, you guarantee that buttons in your application behave just like buttons in any other Cocoa application, assuring a high level of consistency in appearance and behavior across applications.\cb4 \
\cb2 A view should ensure it is displaying the model correctly. Consequently, it usually needs to know about changes to the model. Because model objects should not be tied to specific view objects, they need a generic way of indicating that they have changed.\cb4 \
\pard\pardeftab720\partightenfactor0

\fs32\fsmilli16250 \cf0 \cb2 Controller Objects Tie the Model to the View\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 A controller object acts as the intermediary between the application's view objects and its model objects. Controllers are often in charge of making sure the views have access to the model objects they need to display and act as the conduit through which views learn about changes to the model. Controller objects can also perform set-up and coordinating tasks for an application and manage the life cycles of other objects.\cb4 \
\cb2 In a typical Cocoa MVC design, when users enter a value or indicate a choice through a view object, that value or choice is communicated to a controller object. The controller object might interpret the user input in some application-specific way and then either may tell a model object what to do with this input\'97for example, "add a new value" or "delete the current record"\'97or it may have the model object reflect a changed value in one of its properties. Based on this same user input, some controller objects might also tell a view object to change an aspect of its appearance or behavior, such as telling a button to disable itself. Conversely, when a model object changes\'97say, a new data source is accessed\'97the model object usually communicates that change to a controller object, which then requests one or more view objects to update themselves accordingly.\cb4 \
\cb2 Controller objects can be either reusable or nonreusable, depending on their general type. \cf7 Types of Cocoa Controller Objects\cf0  describes the different types of controller objects in Cocoa.\cb4 \
\pard\pardeftab720\partightenfactor0

\fs32\fsmilli16250 \cf0 \cb2 Combining Roles\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 One can merge the MVC roles played by an object, making an object, for example, fulfill both the controller and view roles\'97in which case, it would be called a view controller. In the same way, you can also have model-controller objects. For some applications, combining roles like this is an acceptable design.\cb4 \
\cb2 A model controller is a controller that concerns itself mostly with the model layer. It \'93owns\'94 the model; its primary responsibilities are to manage the model and communicate with view objects. Action methods that apply to the model as a whole are typically implemented in a model controller. The document architecture provides a number of these methods for you; for example, an 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSDocument/a
\f0\fs26 \cf0  object (which is a central part of the document architecture) automatically handles action methods related to saving files.\cb4 \
\cb2 A view controller is a controller that concerns itself mostly with the view layer. It \'93owns\'94 the interface (the views); its primary responsibilities are to manage the interface and communicate with the model. Action methods concerned with data displayed in a view are typically implemented in a view controller. An 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSWindowController/a
\f0\fs26 \cf0  object (also part of the document architecture) is an example of a view controller.\cb4 \
\pard\pardeftab720\partightenfactor0
\cf7 \cb2 Design Guidelines for MVC Applications\cf0  offers some design advice concerning objects with merged MVC roles.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Further Reading:
\f0\b0 \'a0a target="_self" Document-Based Applications Overview/a discusses the distinction between a model controller and a view controller from another perspective.\cb4 \
\
\pard\pardeftab720\partightenfactor0

\fs37\fsmilli18850 \cf0 \cb2 Types of Cocoa Controller Objects\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 The section \cf7 Controller Objects Tie the Model to the View\cf0  sketches the abstract outline of a controller object, but in practice the picture is far more complex. In Cocoa there are two general kinds of controller objects: mediating controllers and coordinating controllers. Each kind of controller object is associated with a different set of classes and each provides a different range of behaviors.\cb4 \
\cb2 A mediating controller is typically an object that inherits from the 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSController/a
\f0\fs26 \cf0  class. Mediating controller objects are used in the Cocoa bindings technology. They facilitate\'97or mediate\'97the flow of data between view objects and model objects.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 iOS Note:
\f0\b0 \'a0AppKit implements the 
\f2\fs26\fsmilli13390 \cf6 NSController
\f0\fs26 \cf0  class and its subclasses. These classes and the bindings technology are not available in iOS.\cb4 \
\
\pard\pardeftab720\partightenfactor0
\cf0 \cb2 Mediating controllers are typically ready-made objects that you drag from the Interface Builder library. You can configure these objects to establish the bindings between properties of view objects and properties of the controller object, and then between those controller properties and specific properties of a model object. As a result, when users change a value displayed in a view object, the new value is automatically communicated to a model object for storage\'97via the mediating controller; and when a property of a model changes its value, that change is communicated to a view for display. The abstract 
\f2\fs26\fsmilli13390 \cf6 NSController
\f0\fs26 \cf0  class and its concrete subclasses\'97
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSObjectController/a
\f0\fs26 \cf0 , 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSArrayController/a
\f0\fs26 \cf0 , 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSUserDefaultsController/a
\f0\fs26 \cf0 , and 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSTreeController/a
\f0\fs26 \cf0 \'97provide supporting features such as the ability to commit and discard changes and the management of selections and placeholder values.\cb4 \
\cb2 A coordinating controller is typically an 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSWindowController/a
\f0\fs26 \cf0  or 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSDocumentController/a
\f0\fs26 \cf0  object (available only in AppKit), or an instance of a custom subclass of {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSObject/Description.html#//apple_ref/occ/cl/NSObject"}}{\fldrslt 
\f2\fs26\fsmilli13390 \cf7 NSObject}}. Its role in an application is to oversee\'97or coordinate\'97the functioning of the entire application or of part of the application, such as the objects unarchived from a nib file. A coordinating controller provides services such as:\cb4 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls4\ilvl0\cf0 \cb2 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Responding to delegation messages and observing notifications\cb4 \
\ls4\ilvl0\cb2 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Responding to action messages\cb4 \
\ls4\ilvl0\cb2 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Managing the life cycle of owned objects (for example, releasing them at the proper time)\cb4 \
\ls4\ilvl0\cb2 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Establishing connections between objects and performing other set-up tasks\cb4 \
\pard\pardeftab720\partightenfactor0

\f2\fs26\fsmilli13390 \cf6 \cb2 NSWindowController
\f0\fs26 \cf0  and 
\f2\fs26\fsmilli13390 \cf6 NSDocumentController
\f0\fs26 \cf0  are classes that are part of the Cocoa architecture for document-based applications. Instances of these classes provide default implementations for several of the services listed above, and you can create subclasses of them to implement more application-specific behavior. You can even use 
\f2\fs26\fsmilli13390 \cf6 NSWindowController
\f0\fs26 \cf0  objects to manage windows in an application that is not based on the document architecture.\cb4 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb2 A coordinating controller frequently owns the objects archived in a nib file. As File\'92s Owner, the coordinating controller is external to the objects in the nib file and manages those objects. These owned objects include mediating controllers as well as window objects and view objects. See \cf7 MVC as a Compound Design Pattern\cf0  for more on coordinating controllers as File's Owner.\cb4 \
\cb2 Instances of custom 
\f2\fs26\fsmilli13390 \cf6 NSObject
\f0\fs26 \cf0  subclasses can be entirely suitable as coordinating controllers. These kinds of controller objects combine both mediating and coordinating functions. For their mediating behavior, they make use of mechanisms such as target-action, outlets, delegation, and notifications to facilitate the movement of data between view objects and model objects. They tend to contain a lot of glue code and, because that code is exclusively application-specific, they are the least reusable kind of object in an application.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Further Reading:
\f0\b0 \'a0For more on controller objects in their role as mediators, see the information on the Mediator design pattern in \cf7 Mediator\cf0 . For more on the Cocoa bindings technology, see a target="_self" Cocoa Bindings Programming Topics/a.\cb4 \
\
\pard\pardeftab720\partightenfactor0

\fs37\fsmilli18850 \cf0 \cb2 MVC as a Compound Design Pattern\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 Model-View-Controller is a design pattern that is composed of several more basic design patterns. These basic patterns work together to define the functional separation and paths of communication that are characteristic of an MVC application. However, the traditional notion of MVC assigns a set of basic patterns different from those that Cocoa assigns. The difference primarily lies in the roles given to the controller and view objects of an application.\cb4 \
\cb2 In the original (Smalltalk) conception, MVC is made up of the Composite, Strategy, and Observer patterns.\cb4 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls5\ilvl0\cf0 \cb2 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Composite\'97The view objects in an application are actually a composite of nested views that work together in a coordinated fashion (that is, the view hierarchy). These display components range from a window to compound views, such as a table view, to individual views, such as buttons. User input and display can take place at any level of the composite structure.\cb4 \
\ls5\ilvl0\cb2 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Strategy\'97A controller object implements the strategy for one or more view objects. The view object confines itself to maintaining its visual aspects, and it delegates to the controller all decisions about the application-specific meaning of the interface behavior.\cb4 \
\ls5\ilvl0\cb2 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Observer\'97A model object keeps interested objects in an application\'97usually view objects\'97advised of changes in its state.\cb4 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb2 The traditional way the Composite, Strategy, and Observer patterns work together is depicted by Figure 4-6: The user manipulates a view at some level of the composite structure and, as a result, an event is generated. A controller object receives the event and interprets it in an application-specific way\'97that is, it applies a strategy. This strategy can be to request (via message) a model object to change its state or to request a view object (at some level of the composite structure) to change its behavior or appearance. The model object, in turn, notifies all objects who have registered as observers when its state changes; if the observer is a view object, it may update its appearance accordingly.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Figure 4-6
\f0\b0 \'a0\'a0Traditional version of MVC as a compound pattern\cb4 \
\pard\pardeftab720\partightenfactor0
\cf0 {{\NeXTGraphic traditional_mvc.gif \width10260 \height3920 \noorient
}¬}\pard\pardeftab720\partightenfactor0
\cf0 \
\cb2 The Cocoa version of MVC as a compound pattern has some similarities to the traditional version, and in fact it is quite possible to construct a working application based on the diagram in Figure 4-6. By using the bindings technology, you can easily create a Cocoa MVC application whose views directly observe model objects to receive notifications of state changes. However, there is a theoretical problem with this design. View objects and model objects should be the most reusable objects in an application. View objects represent the "look and feel" of an operating system and the applications that system supports; consistency in appearance and behavior is essential, and that requires highly reusable objects. Model objects by definition encapsulate the data associated with a problem domain and perform operations on that data. Design-wise, it's best to keep model and view objects separate from each other, because that enhances their reusability.\cb4 \
\cb2 In most Cocoa applications, notifications of state changes in model objects are communicated to view objects through controller objects. Figure 4-7 shows this different configuration, which appears much cleaner despite the involvement of two more basic design patterns.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Figure 4-7
\f0\b0 \'a0\'a0Cocoa version of MVC as a compound design pattern\cb4 \
\pard\pardeftab720\partightenfactor0
\cf0 {{\NeXTGraphic cocoa_mvc.gif \width10280 \height3720 \noorient
}¬}\pard\pardeftab720\partightenfactor0
\cf0 \
\cb2 The controller object in this compound design pattern incorporates the Mediator pattern as well as the Strategy pattern; it mediates the flow of data between model and view objects in both directions. Changes in model state are communicated to view objects through the controller objects of an application. In addition, view objects incorporate the Command pattern through their implementation of the target-action mechanism.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Note:
\f0\b0 \'a0The target-action mechanism, which enables view objects to communicate user input and choices, can be implemented in both coordinating and mediating controller objects. However, the design of the mechanism differs in each controller type. For coordinating controllers, you connect the view object to its target (the controller object) in Interface Builder and specify an action selector that must conform to a certain signature. Coordinating controllers, by virtue of being delegates of windows and the global application object, can also be in the responder chain. The bindings mechanism used by mediating controllers also connects view objects to targets and allows action signatures with a variable number of parameters of arbitrary types. Mediating controllers, however, aren\'92t in the responder chain.\cb4 \
\
\pard\pardeftab720\partightenfactor0
\cf0 \cb2 There are practical reasons as well as theoretical ones for the revised compound design pattern depicted in Figure 4-7, especially when it comes to the Mediator design pattern. Mediating controllers derive from concrete subclasses of 
\f2\fs26\fsmilli13390 \cf6 NSController
\f0\fs26 \cf0 , and these classes, besides implementing the Mediator pattern, offer many features that applications should take advantage of, such as the management of selections and placeholder values. And if you opt not to use the bindings technology, your view object could use a mechanism such as the Cocoa notification center to receive notifications from a model object. But this would require you to create a custom view subclass to add the knowledge of the notifications posted by the model object.\cb4 \
\cb2 In a well-designed Cocoa MVC application, coordinating controller objects often own mediating controllers, which are archived in nib files. Figure 4-8 shows the relationships between the two types of controller objects.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Figure 4-8
\f0\b0 \'a0\'a0Coordinating controller as the owner of a nib file\cb4 \
\pard\pardeftab720\partightenfactor0
\cf0 {{\NeXTGraphic cocoa_mvc_coord.gif \width5560 \height6900 \noorient
}¬}\pard\pardeftab720\partightenfactor0
\cf0 \
\pard\pardeftab720\partightenfactor0

\fs37\fsmilli18850 \cf0 \cb2 Design Guidelines for MVC Applications\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 The following guidelines apply to Model-View-Controller considerations in the design of applications:\cb4 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls6\ilvl0\cf0 \cb2 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Although you can use an instance of a custom subclass of {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSObject/Description.html#//apple_ref/occ/cl/NSObject"}}{\fldrslt 
\f2\fs26\fsmilli13390 \cf7 NSObject}} as a mediating controller, there's no reason to go through all the work required to make it one. Use instead one of the ready-made 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSController/a
\f0\fs26 \cf0  objects designed for the Cocoa bindings technology; that is, use an instance of 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSObjectController/a
\f0\fs26 \cf0 , 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSArrayController/a
\f0\fs26 \cf0 , 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSUserDefaultsController/a
\f0\fs26 \cf0 , or 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSTreeController/a
\f0\fs26 \cf0 \'97or a custom subclass of one of these concrete 
\f2\fs26\fsmilli13390 \cf6 NSController
\f0\fs26 \cf0  subclasses.However, if the application is very simple and you feel more comfortable writing the glue code needed to implement mediating behavior using outlets and target-action, feel free to use an instance of a custom 
\f2\fs26\fsmilli13390 \cf6 NSObject
\f0\fs26 \cf0  subclass as a mediating controller. In a custom 
\f2\fs26\fsmilli13390 \cf6 NSObject
\f0\fs26 \cf0  subclass, you can also implement a mediating controller in the 
\f2\fs26\fsmilli13390 \cf6 NSController
\f0\fs26 \cf0  sense, using key-value coding, key-value observing, and the editor protocols.\cb4 \
\ls6\ilvl0\cb2 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Although you can combine MVC roles in an object, the best overall strategy is to keep the separation between roles. This separation enhances the reusability of objects and the extensibility of the program they're used in. If you are going to merge MVC roles in a class, pick a predominant role for that class and then (for maintenance purposes) use categories in the same implementation file to extend the class to play other roles.\cb4 \
\ls6\ilvl0\cb2 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
A goal of a well-designed MVC application should be to use as many objects as possible that are (theoretically, at least) reusable. In particular, view objects and model objects should be highly reusable. (The ready-made mediating controller objects, of course, are reusable.) Application-specific behavior is frequently concentrated as much as possible in controller objects.\cb4 \
\ls6\ilvl0\cb2 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Although it is possible to have views directly observe models to detect changes in state, it is best not to do so. A view object should always go through a mediating controller object to learn about changes in an model object. The reason is two-fold:\cb4 \
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\partightenfactor0
\ls6\ilvl1\cf0 \cb2 \kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
If you use the bindings mechanism to have view objects directly observe the properties of model objects, you bypass all the advantages that 
\f2\fs26\fsmilli13390 \cf6 NSController
\f0\fs26 \cf0  and its subclasses give your application: selection and placeholder management as well as the ability to commit and discard changes.\cb4 \
\ls6\ilvl1\cb2 \kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
If you don't use the bindings mechanism, you have to subclass an existing view class to add the ability to observe change notifications posted by a model object.\cb4 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls6\ilvl0\cf0 \cb2 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Strive to limit code dependency in the classes of your application. The greater the dependency a class has on another class, the less reusable it is. Specific recommendations vary by the MVC roles of the two classes involved:\cb4 \
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\partightenfactor0
\ls6\ilvl1\cf0 \cb2 \kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
A view class shouldn't depend on a model class (although this may be unavoidable with some custom views).\cb4 \
\ls6\ilvl1\cb2 \kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
A view class shouldn't have to depend on a mediating controller class.\cb4 \
\ls6\ilvl1\cb2 \kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
A model class shouldn't depend on anything other than other model classes.\cb4 \
\ls6\ilvl1\cb2 \kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
A mediating controller class shouldn\'92t depend on a model class (although, like views, this may be necessary if it's a custom controller class).\cb4 \
\ls6\ilvl1\cb2 \kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
A mediating controller class shouldn't depend on view classes or on coordinating controller classes.\cb4 \
\ls6\ilvl1\cb2 \kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
A coordinating controller class depends on classes of all MVC role types.\cb4 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls6\ilvl0\cf0 \cb2 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
If Cocoa offers an architecture that solves a programming problem, and this architecture assigns MVC roles to objects of specific types, use that architecture. It will be much easier to put your project together if you do. The document architecture, for example, includes an Xcode project template that configures an 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSDocument/a
\f0\fs26 \cf0  object (per-nib model controller) as File's Owner.\cb4 \
\pard\pardeftab720\partightenfactor0

\fs37\fsmilli18850 \cf0 \cb2 Model-View-Controller in Cocoa (OS X)\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 The Model-View-Controller design pattern is fundamental to many Cocoa mechanisms and technologies. As a consequence, the importance of using MVC in object-oriented design goes beyond attaining greater reusability and extensibility for your own applications. If your application is to incorporate a Cocoa technology that is MVC-based, your application will work best if its design also follows the MVC pattern. It should be relatively painless to use these technologies if your application has a good MVC separation, but it will take more effort to use such a technology if you don\'92t have a good separation.\cb4 \
\cb2 Cocoa in OS X includes the following architectures, mechanisms, and technologies that are based on Model-View-Controller:\cb4 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls7\ilvl0
\f1\b \cf0 \cb2 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Document architecture
\f0\b0 . In this architecture, a document-based application consists of a controller object for the entire application (
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSDocumentController/a
\f0\fs26 \cf0 ), a controller object for each document window (
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSWindowController/a
\f0\fs26 \cf0 ), and an object that combines controller and model roles for each document (
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSDocument/a
\f0\fs26 \cf0 ).\cb4 \
\ls7\ilvl0
\f1\b \cb2 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Bindings
\f0\b0 . MVC is central to the bindings technology of Cocoa. The concrete subclasses of the abstract 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSController/a
\f0\fs26 \cf0  provide ready-made controller objects that you can configure to establish bindings between view objects and properly designed model objects.\cb4 \
\ls7\ilvl0
\f1\b \cb2 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Application scriptability
\f0\b0 . When designing an application to make it scriptable, it is essential not only that it follow the MVC design pattern but that your application\'92s model objects are properly designed. Scripting commands that access application state and request application behavior should usually be sent to model objects or controller objects.\cb4 \
\ls7\ilvl0
\f1\b \cb2 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Core Data
\f0\b0 . The Core Data framework manages graphs of model objects and ensures the persistence of those objects by saving them to (and retrieving them from) a persistent store. Core Data is tightly integrated with the Cocoa bindings technology. The MVC and object modeling design patterns are essential determinants of the Core Data architecture.\cb4 \
\ls7\ilvl0
\f1\b \cb2 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Undo
\f0\b0 . In the undo architecture, model objects once again play a central role. The primitive methods of model objects (which are usually its accessor methods) are often where you implement undo and redo operations. The view and controller objects of an action may also be involved in these operations; for example, you might have such objects give specific titles to the undo and redo menu items, or you might have them undo selections in a text view.\cb4 \
\pard\pardeftab720\partightenfactor0

\fs48\fsmilli24310 \cf5 \cb2 Object Modeling\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 This section defines terms and presents examples of object modeling and key-value coding that are specific to Cocoa bindings and the Core Data framework. Understanding terms such as key paths is fundamental to using these technologies effectively. This section is recommended reading if you are new to object-oriented design or key-value coding.\cb4 \
\cb2 When using the Core Data framework, you need a way to describe your model objects that does not depend on views and controllers. In a good reusable design, views and controllers need a way to access model properties without imposing dependencies between them. The Core Data framework solves this problem by borrowing concepts and terms from database technology\'97specifically, the entity-relationship model.\cb4 \
\cb2 Entity-relationship modeling is a way of representing objects typically used to describe a data source\'92s data structures in a way that allows those data structures to be mapped to objects in an object-oriented system. Note that entity-relationship modeling isn\'92t unique to Cocoa; it\'92s a popular discipline with a set of rules and terms that are documented in database literature. It is a representation that facilitates storage and retrieval of objects in a data source. A data source can be a database, a file, a web service, or any other persistent store. Because it is not dependent on any type of data source it can also be used to represent any kind of object and its relationship to other objects.\cb4 \
\cb2 In the entity-relationship model, the objects that hold data are called entities, the components of an entity are called attributes, and the references to other data-bearing objects are called relationships. Together, attributes and relationships are known as properties. With these three simple components (entities, attributes, and relationships), you can model systems of any complexity.\cb4 \
\cb2 Cocoa uses a modified version of the traditional rules of entity-relationship modeling referred to in this document as object modeling. Object modeling is particularly useful in representing model objects in the Model-View-Controller (MVC) design pattern. This is not surprising because even in a simple Cocoa application, models are typically persistent\'97that is, they are stored in a data container such as a file.\cb4 \
\pard\pardeftab720\partightenfactor0

\fs37\fsmilli18850 \cf0 \cb2 Entities\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 Entities are model objects. In the MVC design pattern, model objects are the objects in your application that encapsulate specified data and provide methods that operate on that data. They are usually persistent but more importantly, model objects are not dependent on how the data is displayed to the user.\cb4 \
\cb2 For example, a structured collection of model objects (an object model) can be used to represent a company\'92s customer base, a library of books, or a network of computers. A library book has attributes\'97such as the book title, ISBN number, and copyright date\'97and relationships to other objects\'97such as the author and library member. In theory, if the parts of a system can be identified, the system can be expressed as an object model.\cb4 \
\cb2 Figure 4-9 shows an example object model used in an employee management application. In this model, Department models a department and Employee models an employee.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Figure 4-9
\f0\b0 \'a0\'a0Employee management application object diagram\cb4 \
\pard\pardeftab720\partightenfactor0
\cf0 {{\NeXTGraphic employee_management_app.gif \width7560 \height1760 \noorient
}¬}\pard\pardeftab720\partightenfactor0
\cf0 \
\pard\pardeftab720\partightenfactor0

\fs37\fsmilli18850 \cf0 \cb2 Attributes\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 Attributes represent structures that contain data. An attribute of an object may be a simple value, such as a scalar (for example, an 
\f2\fs26\fsmilli13390 \cf6 integer
\f0\fs26 \cf0 , 
\f2\fs26\fsmilli13390 \cf6 float
\f0\fs26 \cf0 , or 
\f2\fs26\fsmilli13390 \cf6 double
\f0\fs26 \cf0  value), but can also be a C structure (for example an array of 
\f2\fs26\fsmilli13390 \cf6 char
\f0\fs26 \cf0  values or an {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/TypesAndConstants/FoundationTypesConstants/Description.html#//apple_ref/c/tdef/NSPoint"}}{\fldrslt 
\f2\fs26\fsmilli13390 \cf7 NSPoint}} structure) or an instance of a primitive class (such as, {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSNumber/Description.html#//apple_ref/occ/cl/NSNumber"}}{\fldrslt 
\f2\fs26\fsmilli13390 \cf7 NSNumber}}, {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSDataClassCluster/Description.html#//apple_ref/occ/cl/NSData"}}{\fldrslt 
\f2\fs26\fsmilli13390 \cf7 NSData}}, or 
\f2\fs26\fsmilli13390 \cf6 a target="_self" NSColor/a
\f0\fs26 \cf0  in Cocoa). Immutable objects such as 
\f2\fs26\fsmilli13390 \cf6 NSColor
\f0\fs26 \cf0  are usually considered attributes too. (Note that Core Data natively supports only a specific set of attribute types, as described in a target="_self" NSAttributeDescription Class Reference/a. You can, however, use additional attribute types, as described in a target="_self" Non-Standard Persistent Attributes/a in a target="_self" Core Data Programming Guide/a.)\cb4 \
\cb2 In Cocoa, an attribute typically corresponds to a model\'92s instance variable or accessor method. For example, Employee has 
\f2\fs26\fsmilli13390 \cf6 firstName
\f0\fs26 \cf0 , 
\f2\fs26\fsmilli13390 \cf6 lastName
\f0\fs26 \cf0 , and 
\f2\fs26\fsmilli13390 \cf6 salary
\f0\fs26 \cf0  instance variables. In an employee management application, you might implement a table view to display a collection of Employee objects and some of their attributes, as shown in Figure 4-10. Each row in the table corresponds to an instance of Employee, and each column corresponds to an attribute of Employee.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Figure 4-10
\f0\b0 \'a0\'a0Employees table view\cb4 \
\pard\pardeftab720\partightenfactor0
\cf0 {{\NeXTGraphic employeetable.gif \width5960 \height3820 \noorient
}¬}\pard\pardeftab720\partightenfactor0
\cf0 \
\pard\pardeftab720\partightenfactor0

\fs37\fsmilli18850 \cf0 \cb2 Relationships\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 Not all properties of a model are attributes\'97some properties are relationships to other objects. Your application is typically modeled by multiple classes. At runtime, your object model is a collection of related objects that make up an object graph. These are typically the persistent objects that your users create and save to some data container or file before terminating the application (as in a document-based application). The relationships between these model objects can be traversed at runtime to access the properties of the related objects.\cb4 \
\cb2 For example, in the employee management application, there are relationships between an employee and the department in which the employee works, and between an employee and the employee\'92s manager. Because a manager is also an employee, the employee\'96manager relationship is an example of a reflexive relationship\'97a relationship from an entity to itself.\cb4 \
\cb2 Relationships are inherently bidirectional, so conceptually at least there are also relationships between a department and the employees that work in the department, and an employee and the employee\'92s direct reports. \cf7 Figure 4-11\cf0  illustrates the relationships between a Department and an Employee entity, and the Employee reflexive relationship. In this example, the Department entity\'92s \'93employees\'94 relationship is the inverse of the Employee entity\'92s \'93department\'94 relationship. It is possible, however, for relationships to be navigable in only one direction\'97for there to be no inverse relationship. If, for example, you are never interested in finding out from a department object what employees are associated with it, then you do not have to model that relationship. (Note that although this is true in the general case, Core Data may impose additional constraints over general Cocoa object modeling\'97not modeling the inverse should be considered an extremely advanced option.)\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Figure 4-11
\f0\b0 \'a0\'a0Relationships in the employee management application\cb4 \
\pard\pardeftab720\partightenfactor0
\cf0 {{\NeXTGraphic relationship_employee_app.gif \width9340 \height1760 \noorient
}¬}\pard\pardeftab720\partightenfactor0
\cf0 \
\pard\pardeftab720\partightenfactor0

\fs32\fsmilli16250 \cf0 \cb2 Relationship Cardinality and Ownership\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 Every relationship has a cardinality; the cardinality tells you how many destination objects can (potentially) resolve the relationship. If the destination object is a single object, then the relationship is called a to-one relationship. If there may be more than one object in the destination, then the relationship is called a to-many relationship.\cb4 \
\cb2 Relationships can be mandatory or optional. A mandatory relationship is one where the destination is required\'97for example, every employee must be associated with a department. An optional relationship is, as the name suggests, optional\'97for example, not every employee has direct reports. So the 
\f2\fs26\fsmilli13390 \cf6 directReports
\f0\fs26 \cf0  relationship depicted in Figure 4-12 is optional.\cb4 \
\cb2 It is also possible to specify a range for the cardinality. An optional to-one relationship has a range 0-1. An employee may have any number of direct reports, or a range that specifies a minimum and a maximum, for example, 0-15, which also illustrates an optional to-many relationship.\cb4 \
\cb2 Figure 4-12 illustrates the cardinalities in the employee management application. The relationship between an Employee object and a Department object is a mandatory to-one relationship\'97an employee must belong to one, and only one, department. The relationship between a Department and its Employee objects is an optional to-many relationship (represented by a \'93*\'94). The relationship between an employee and a manager is an optional to-one relationship (denoted by the range 0-1)\'97top-ranking employees do not have managers.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Figure 4-12
\f0\b0 \'a0\'a0Relationship cardinality\cb4 \
\pard\pardeftab720\partightenfactor0
\cf0 {{\NeXTGraphic relationship_cardinality.gif \width9360 \height1760 \noorient
}¬}\pard\pardeftab720\partightenfactor0
\cf0 \
\cb2 Note also that destination objects of relationships are sometimes owned and sometimes shared.\cb4 \
\pard\pardeftab720\partightenfactor0

\fs37\fsmilli18850 \cf0 \cb2 Accessing Properties\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 In order for models, views, and controllers to be independent of each other, you need to be able to access properties in a way that is independent of a model\'92s implementation. This is accomplished by using key-value pairs.\cb4 \
\pard\pardeftab720\partightenfactor0

\fs32\fsmilli16250 \cf0 \cb2 Keys\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 You specify properties of a model using a simple key, often a string. The corresponding view or controller uses the key to look up the corresponding attribute value. This design enforces the notion that the attribute itself doesn\'92t necessarily contain the data\'97the value can be indirectly obtained or derived.\cb4 \
\cb2 Key-value coding is used to perform this lookup; it is a mechanism for accessing an object\'92s properties indirectly and, in certain contexts, automatically. Key-value coding works by using the names of the object\'92s properties\'97typically its instance variables or accessor methods\'97as keys to access the values of those properties.\cb4 \
\cb2 For example, you might obtain the name of a Department object using a 
\f2\fs26\fsmilli13390 \cf6 name
\f0\fs26 \cf0  key. If the Department object either has an instance variable or a method called 
\f2\fs26\fsmilli13390 \cf6 name
\f0\fs26 \cf0  then a value for the key can be returned (if it doesn\'92t have either, an error is returned). Similarly, you might obtain Employee attributes using the 
\f2\fs26\fsmilli13390 \cf6 firstName
\f0\fs26 \cf0 , 
\f2\fs26\fsmilli13390 \cf6 lastName
\f0\fs26 \cf0 , and 
\f2\fs26\fsmilli13390 \cf6 salary
\f0\fs26 \cf0  keys.\cb4 \
\pard\pardeftab720\partightenfactor0

\fs32\fsmilli16250 \cf0 \cb2 Values\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 All values for a particular attribute of a given entity are of the same data type. The data type of an attribute is specified in the declaration of its corresponding instance variable or in the return value of its accessor method. For example, the data type of the Department object 
\f2\fs26\fsmilli13390 \cf6 name
\f0\fs26 \cf0  attribute may be an 
\f2\fs26\fsmilli13390 \cf6 NSString
\f0\fs26 \cf0  object in Objective-C.\cb4 \
\cb2 Note that key-value coding returns only object values. If the return type or the data type for the specific accessor method or instance variable used to supply the value for a specified key is not an object, then an 
\f2\fs26\fsmilli13390 \cf6 NSNumber
\f0\fs26 \cf0  or 
\f2\fs26\fsmilli13390 \cf6 NSValue
\f0\fs26 \cf0  object is created for that value and returned in its place. If the 
\f2\fs26\fsmilli13390 \cf6 name
\f0\fs26 \cf0  attribute of Department is of type 
\f2\fs26\fsmilli13390 \cf6 NSString
\f0\fs26 \cf0 , then, using key-value coding, the value returned for the 
\f2\fs26\fsmilli13390 \cf6 name
\f0\fs26 \cf0  key of a Department object is an 
\f2\fs26\fsmilli13390 \cf6 NSString
\f0\fs26 \cf0  object. If the 
\f2\fs26\fsmilli13390 \cf6 budget
\f0\fs26 \cf0  attribute of Department is of type 
\f2\fs26\fsmilli13390 \cf6 float
\f0\fs26 \cf0 , then, using key-value coding, the value returned for the 
\f2\fs26\fsmilli13390 \cf6 budget
\f0\fs26 \cf0  key of a Department object is an 
\f2\fs26\fsmilli13390 \cf6 NSNumber
\f0\fs26 \cf0  object.\cb4 \
\cb2 Similarly, when you set a value using key-value coding, if the data type required by the appropriate accessor or instance variable for the specified key is not an object, then the value is extracted from the passed object using the appropriate 
\f2\fs26\fsmilli13390 \cf6 -
\f0\fs26 \cf0 type
\f2\fs26\fsmilli13390 \cf6 Value
\f0\fs26 \cf0  method.\cb4 \
\cb2 The value of a to-one relationship is simply the destination object of that relationship. For example, the value of the 
\f2\fs26\fsmilli13390 \cf6 department
\f0\fs26 \cf0  property of an Employee object is a Department object. The value of a to-many relationship is the collection object. The collection can be a set or an array. If you use Core Data it is a set; otherwise, it is typically an array) that contains the destination objects of that relationship. For example, the value of the 
\f2\fs26\fsmilli13390 \cf6 employees
\f0\fs26 \cf0  property of an Department object is a collection containing Employee objects. Figure 4-13 shows an example object graph for the employee management application.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Figure 4-13
\f0\b0 \'a0\'a0Object graph for the employee management application\cb4 \
\pard\pardeftab720\partightenfactor0
\cf0 {{\NeXTGraphic object_graph.gif \width9180 \height7760 \noorient
}¬}\pard\pardeftab720\partightenfactor0
\cf0 \
\pard\pardeftab720\partightenfactor0

\fs32\fsmilli16250 \cf0 \cb2 Key Paths\cb4 \
\pard\pardeftab720\partightenfactor0

\fs26 \cf0 \cb2 A key path is a string of dot-separated keys that specify a sequence of object properties to traverse. The property of the first key is determined by, and each subsequent key is evaluated relative to, the previous property. Key paths allow you to specify the properties of related objects in a way that is independent of the model implementation. Using key paths you can specify the path through an object graph, of whatever depth, to a specific attribute of a related object.\cb4 \
\cb2 The key-value coding mechanism implements the lookup of a value given a key path similar to key-value pairs. For example, in the employee-management application you might access the name of a Department via an Employee object using the 
\f2\fs26\fsmilli13390 \cf6 department.name
\f0\fs26 \cf0  key path where 
\f2\fs26\fsmilli13390 \cf6 department
\f0\fs26 \cf0  is a relationship of Employee and 
\f2\fs26\fsmilli13390 \cf6 name
\f0\fs26 \cf0  is an attribute of Department. Key paths are useful if you want to display an attribute of a destination entity. For example, the employee table view in Figure 4-14 is configured to display the name of the employee\'92s department object, not the department object itself. Using Cocoa bindings, the value of the Department column is bound to 
\f2\fs26\fsmilli13390 \cf6 department.name
\f0\fs26 \cf0  of the Employee objects in the displayed array.\cb4 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf0 \cb2 Figure 4-14
\f0\b0 \'a0\'a0Employees table view showing department name\cb4 \
\pard\pardeftab720\partightenfactor0
\cf0 {{\NeXTGraphic employeedepttable.gif \width5940 \height3780 \noorient
}¬}\pard\pardeftab720\partightenfactor0
\cf0 \
\cb2 Not every relationship in a key path necessarily has a value. For example, the 
\f2\fs26\fsmilli13390 \cf6 manager
\f0\fs26 \cf0  relationship can be 
\f2\fs26\fsmilli13390 \cf6 nil
\f0\fs26 \cf0  if the employee is the CEO. In this case, the key-value coding mechanism does not break\'97it simply stops traversing the path and returns an appropriate value, such as 
\f2\fs26\fsmilli13390 \cf6 nil.
\f0\fs26 \cf0 \cb4 \
\pard\pardeftab720\partightenfactor0
{\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/Cocoa/Conceptual/CocoaFundamentals/CommunicatingWithObjects/CommunicateWithObjects.html"}}{\fldrslt \cf7 \cb2 Next}}\cf7 \
\pard\pardeftab720\partightenfactor0
{\field{\*\fldinst{HYPERLINK "https://developer.apple.com/legacy/library/documentation/Cocoa/Conceptual/CocoaFundamentals/AddingBehaviortoaCocoaProgram/AddingBehaviorCocoa.html"}}{\fldrslt \cf7 \cb2 Previous}}\
}